var Oomph3D = (function (exports) {
  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var Scene = function () {
      function Scene() {
          classCallCheck(this, Scene);

          this._children = [];
          this._lights = [];
      }

      createClass(Scene, [{
          key: 'addChild',
          value: function addChild(mesh) {
              if (this._children.indexOf(mesh) === -1) {
                  this._children.push(mesh);
                  mesh.onMaterialUpdated = this._onMeshMaterialUpdated;
                  if (this._onChildAdded) this._onChildAdded(mesh);
              }
          }
      }, {
          key: 'removeChild',
          value: function removeChild(mesh) {
              this._children = this._children.filter(function (currentMesh) {
                  return currentMesh !== mesh;
              });
          }
      }, {
          key: 'addLight',
          value: function addLight(light) {
              if (this._lights.indexOf(light) === -1) {
                  if (light.isDirectional) {
                      if (this._directionalLight) {
                          throw new Error('Scene: Scene already contains a directional light. Remove the existing one before adding a new one');
                      }
                      this._directionalLight = light;
                  } else {
                      this._lights.push(light);
                  }
              }
          }
      }, {
          key: 'removeLight',
          value: function removeLight(light) {
              if (light.isDirectional) {
                  this._directionalLight = undefined;
              } else {
                  this._lights = this._lights.filter(function (currentLight) {
                      return currentLight !== light;
                  });
              }
          }
      }, {
          key: 'resize',
          value: function resize(canvasWidth, canvasHeight) {
              if (this._camera) {
                  this._camera.resize(canvasWidth, canvasHeight);
              }
          }
      }, {
          key: 'update',
          value: function update() {
              if (this._camera) {
                  this._camera.update();
              }
          }
      }, {
          key: 'children',
          get: function get$$1() {
              return this._children;
          }
      }, {
          key: 'camera',
          get: function get$$1() {
              return this._camera;
          },
          set: function set$$1(camera) {
              this._camera = camera;
              if (this._onCameraAdded) this._onCameraAdded(camera);
          }
      }, {
          key: 'lights',
          get: function get$$1() {
              return this._lights;
          }
      }, {
          key: 'directionalLight',
          get: function get$$1() {
              return this._directionalLight;
          }
      }, {
          key: 'onChildAdded',
          set: function set$$1(value) {
              this._onChildAdded = value;
          }
      }, {
          key: 'onMeshMaterialUpdated',
          set: function set$$1(value) {
              this._onMeshMaterialUpdated = value;
          }
      }, {
          key: 'onCameraAdded',
          set: function set$$1(value) {
              this._onCameraAdded = value;
          }
      }]);
      return Scene;
  }();

  var Program = function () {
      function Program(glContext, vertexShader, fragmentShader) {
          classCallCheck(this, Program);

          this._vertexShader = this._createShader(glContext, glContext.VERTEX_SHADER, vertexShader);
          this._fragmentShader = this._createShader(glContext, glContext.FRAGMENT_SHADER, fragmentShader);
          this._glProgram = this._createGLProgram(glContext);
          this._getAttributeLocations(glContext);
          this._getUniformLocations(glContext);
      }

      createClass(Program, [{
          key: '_createShader',
          value: function _createShader(glContext, type, source) {
              var shader = glContext.createShader(type);
              glContext.shaderSource(shader, source);
              glContext.compileShader(shader);
              var success = glContext.getShaderParameter(shader, glContext.COMPILE_STATUS);
              if (success) return shader;
              var error = 'Program: Error compiling shader: ' + glContext.COMPILE_STATUS;
              glContext.deleteShader(shader);
              throw new Error(error);
          }
      }, {
          key: '_createGLProgram',
          value: function _createGLProgram(glContext) {
              var program = glContext.createProgram();
              glContext.attachShader(program, this._vertexShader);
              glContext.attachShader(program, this._fragmentShader);
              glContext.linkProgram(program);
              var success = glContext.getProgramParameter(program, glContext.LINK_STATUS);
              if (success) return program;
              var error = 'Program: Error compiling program: ' + glContext.getProgramInfoLog(program);
              glContext.deleteProgram(program);
              throw new Error(error);
          }
      }, {
          key: '_getAttributeLocations',
          value: function _getAttributeLocations(glContext) {
              this._positionAttribute = glContext.getAttribLocation(this._glProgram, 'a_position');
              this._normalAttribute = glContext.getAttribLocation(this._glProgram, 'a_normal');
              this._uvAttribute = glContext.getAttribLocation(this._glProgram, 'a_texcoord');
          }
      }, {
          key: '_getUniformLocations',
          value: function _getUniformLocations(glContext) {
              this._colorUniform = glContext.getUniformLocation(this._glProgram, 'u_color');
              this._matrixUniform = glContext.getUniformLocation(this._glProgram, 'u_matrix');
              this._normalMatrixUniform = glContext.getUniformLocation(this._glProgram, 'u_worldMatrix');
              this._lightDirectionUniform = glContext.getUniformLocation(this._glProgram, 'u_reverseLightDirection');
              this._lightColorUniform = glContext.getUniformLocation(this._glProgram, 'u_lightColor');
          }
      }, {
          key: 'positionAttribute',
          get: function get$$1() {
              return this._positionAttribute;
          }
      }, {
          key: 'normalAttribute',
          get: function get$$1() {
              return this._normalAttribute;
          }
      }, {
          key: 'uvAttribute',
          get: function get$$1() {
              return this._uvAttribute;
          }
      }, {
          key: 'colorUniform',
          get: function get$$1() {
              return this._colorUniform;
          }
      }, {
          key: 'matrixUniform',
          get: function get$$1() {
              return this._matrixUniform;
          }
      }, {
          key: 'normalMatrixUniform',
          get: function get$$1() {
              return this._normalMatrixUniform;
          }
      }, {
          key: 'lightDirectionUniform',
          get: function get$$1() {
              return this._lightDirectionUniform;
          }
      }, {
          key: 'lightColorUniform',
          get: function get$$1() {
              return this._lightColorUniform;
          }
      }, {
          key: 'glProgram',
          get: function get$$1() {
              return this._glProgram;
          }
      }]);
      return Program;
  }();

  var normalizeVector = function normalizeVector(vector) {
      var length = Math.sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
      // Don't divide by zero
      if (length > 0.00001) {
          return {
              x: vector.x / length,
              y: vector.y / length,
              z: vector.z / length
          };
      } else {
          return { x: 0, y: 0, z: 0 };
      }
  };
  var subtractVectors = function subtractVectors(vectorA, vectorB) {
      return {
          x: vectorA.x - vectorB.x,
          y: vectorA.y - vectorB.y,
          z: vectorA.z - vectorB.z
      };
  };
  var crossVectors = function crossVectors(vectorA, vectorB) {
      return {
          x: vectorA.y * vectorB.z - vectorA.z * vectorB.y,
          y: vectorA.z * vectorB.x - vectorA.x * vectorB.z,
          z: vectorA.x * vectorB.y - vectorA.y * vectorB.x
      };
  };
  var transformVector = function transformVector(matrix, vector) {
      var result = [0, 0, 0, 0];
      var vectorArray = [vector.x, vector.y, vector.z, vector.w];
      for (var i = 0; i < 4; i++) {
          for (var j = 0; j < 4; j++) {
              result[i] += vectorArray[j] * matrix.value[j * 4 + i];
          }
      }
      return {
          x: result[0],
          y: result[1],
          z: result[2],
          w: 0
      };
  };

  var Matrix4 = function () {
      function Matrix4(matrix) {
          classCallCheck(this, Matrix4);

          this._identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          this._currentValue = matrix || this._identity;
      }

      createClass(Matrix4, [{
          key: 'setToIdentity',
          value: function setToIdentity() {
              this._currentValue = this._identity;
          }
      }, {
          key: 'setToProjection',
          value: function setToProjection(width, height, depth) {
              // Converts from pixels to clipspace
              // Scale by 1.0/resolution
              // Scale by 2.0
              // Translate by -1.0, -1.0
              // Scale Y by -1 (flip Y to make top = 0)
              this._currentValue = [2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1];
          }
      }, {
          key: 'setToOrthographic',
          value: function setToOrthographic(top, right, bottom, left, near, far) {
              // Similar to setToPerspective, but allows you to define the full 3D space
              this._currentValue = [2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, 2 / (near - far), 0, (left + right) / (left - right), (bottom + top) / (bottom - top), (near + far) / (near - far), 1];
          }
      }, {
          key: 'setToPerspective',
          value: function setToPerspective(fieldOfViewInRadians, aspectRatio, near, far) {
              // Adjust the units so they're in clip space
              // Calculate (via Math.tan) the field of view from radians
              // The field of view is basically the rectangle at 'near' and
              // the rectangle found at 'far' getting bigger, increasing the
              // area between them in which objects are rendered
              // The shape of that area is called a 'frustum'
              // Use near and far as the Z-clipping space
              // ie. what we should consider the distance multiplier when
              // adding perspective (z normally = -1 to 1)
              var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
              var rangeInv = 1.0 / (near - far);
              // This assumes there is an eye or camera at 0,0,0
              // Then works out the maths to result in stuff at 'near' being at z = -1
              // Then stuff at 'near' that is half of fieldOfView above or below the center
              // ends up with y = -1 and y = 1 respectively
              // X is just the x-coord multiplied by the 'aspect', which is usually
              // the width of the display area divided by it's height
              this._currentValue = [f / aspectRatio, 0, 0, 0, 0, f, 0, 0, 0, 0, (near + far) * rangeInv, -1, 0, 0, near * far * rangeInv * 2, 0];
          }
      }, {
          key: 'setToLookAt',
          value: function setToLookAt(cameraPosition, target, up) {
              // Get the axis found between the camera and the target
              var zAxis = normalizeVector(subtractVectors(cameraPosition, target));
              // Work out the X axis - it's perpendicular to up and the zAxis
              var xAxis = crossVectors(up, zAxis);
              // Work out the Y axis - it's perpendicular to the Z and X axes
              var yAxis = crossVectors(zAxis, xAxis);
              this._currentValue = [xAxis.x, xAxis.y, xAxis.z, 0, yAxis.x, yAxis.y, yAxis.z, 0, zAxis.x, zAxis.y, zAxis.z, 0, cameraPosition.x, cameraPosition.y, cameraPosition.z, 1];
          }
      }, {
          key: 'copyZToW',
          value: function copyZToW(distanceMultiplier) {
              this._currentValue[11] = this._currentValue[10] * distanceMultiplier;
          }
      }, {
          key: 'translate',
          value: function translate(x, y, z) {
              this.multiply([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1]);
          }
      }, {
          key: 'rotate',
          value: function rotate(angleXRadians, angleYRadians, angleZRadians) {
              if (angleYRadians) this.rotateY(angleYRadians);
              if (angleXRadians) this.rotateX(angleXRadians);
              if (angleZRadians) this.rotateZ(angleZRadians);
          }
      }, {
          key: 'rotateX',
          value: function rotateX(angleInRadians) {
              var cos = Math.cos(angleInRadians);
              var sin = Math.sin(angleInRadians);
              this.multiply([1, 0, 0, 0, 0, cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1]);
          }
      }, {
          key: 'rotateY',
          value: function rotateY(angleInRadians) {
              var cos = Math.cos(angleInRadians);
              var sin = Math.sin(angleInRadians);
              this.multiply([cos, 0, -sin, 0, 0, 1, 0, 0, sin, 0, cos, 0, 0, 0, 0, 1]);
          }
      }, {
          key: 'rotateZ',
          value: function rotateZ(angleInRadians) {
              var cos = Math.cos(angleInRadians);
              var sin = Math.sin(angleInRadians);
              this.multiply([cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
          }
      }, {
          key: 'scale',
          value: function scale(x, y, z) {
              this.multiply([x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1]);
          }
      }, {
          key: 'rotateOnAxis',
          value: function rotateOnAxis(angleInRadians, xAxis, yAxis, zAxis) {
              var cos = Math.cos(angleInRadians);
              var sin = Math.sin(angleInRadians);
              var length = Math.sqrt(xAxis * xAxis + yAxis * yAxis + zAxis * zAxis);
              if (length !== 1) {
                  var inverseLength = 1 / length;
                  xAxis *= inverseLength;
                  yAxis *= inverseLength;
                  zAxis *= inverseLength;
              }
              var inverseCos = 1 - cos;
              var xy = xAxis * yAxis;
              var yz = yAxis * zAxis;
              var zx = zAxis * xAxis;
              var xSin = xAxis * sin;
              var ySin = yAxis * sin;
              var zSin = zAxis * sin;
              this.multiply([xAxis * xAxis * inverseCos - zSin, xy * inverseCos + zSin, zx * inverseCos - ySin, 0, xy * inverseCos - zSin, yAxis * yAxis * inverseCos + cos, yz * inverseCos + xSin, 0, zx * inverseCos + ySin, yz * inverseCos - xSin, zAxis * zAxis * inverseCos + cos, 0, 0, 0, 0, 1]);
          }
      }, {
          key: 'multiply',
          value: function multiply(matrix) {
              var a00 = this._currentValue[0 * 4 + 0];
              var a01 = this._currentValue[0 * 4 + 1];
              var a02 = this._currentValue[0 * 4 + 2];
              var a03 = this._currentValue[0 * 4 + 3];
              var a10 = this._currentValue[1 * 4 + 0];
              var a11 = this._currentValue[1 * 4 + 1];
              var a12 = this._currentValue[1 * 4 + 2];
              var a13 = this._currentValue[1 * 4 + 3];
              var a20 = this._currentValue[2 * 4 + 0];
              var a21 = this._currentValue[2 * 4 + 1];
              var a22 = this._currentValue[2 * 4 + 2];
              var a23 = this._currentValue[2 * 4 + 3];
              var a30 = this._currentValue[3 * 4 + 0];
              var a31 = this._currentValue[3 * 4 + 1];
              var a32 = this._currentValue[3 * 4 + 2];
              var a33 = this._currentValue[3 * 4 + 3];
              var b00 = matrix[0 * 4 + 0];
              var b01 = matrix[0 * 4 + 1];
              var b02 = matrix[0 * 4 + 2];
              var b03 = matrix[0 * 4 + 3];
              var b10 = matrix[1 * 4 + 0];
              var b11 = matrix[1 * 4 + 1];
              var b12 = matrix[1 * 4 + 2];
              var b13 = matrix[1 * 4 + 3];
              var b20 = matrix[2 * 4 + 0];
              var b21 = matrix[2 * 4 + 1];
              var b22 = matrix[2 * 4 + 2];
              var b23 = matrix[2 * 4 + 3];
              var b30 = matrix[3 * 4 + 0];
              var b31 = matrix[3 * 4 + 1];
              var b32 = matrix[3 * 4 + 2];
              var b33 = matrix[3 * 4 + 3];
              this._currentValue = [b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33, b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30, b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31, b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32, b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33, b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30, b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31, b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32, b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33, b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30, b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31, b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32, b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33];
          }
      }, {
          key: 'invert',
          value: function invert() {
              // Create the inverse of the current matrix
              // ie. it should do the opposite of whatever
              // transformation it currently does
              var m00 = this._currentValue[0 * 4 + 0];
              var m01 = this._currentValue[0 * 4 + 1];
              var m02 = this._currentValue[0 * 4 + 2];
              var m03 = this._currentValue[0 * 4 + 3];
              var m10 = this._currentValue[1 * 4 + 0];
              var m11 = this._currentValue[1 * 4 + 1];
              var m12 = this._currentValue[1 * 4 + 2];
              var m13 = this._currentValue[1 * 4 + 3];
              var m20 = this._currentValue[2 * 4 + 0];
              var m21 = this._currentValue[2 * 4 + 1];
              var m22 = this._currentValue[2 * 4 + 2];
              var m23 = this._currentValue[2 * 4 + 3];
              var m30 = this._currentValue[3 * 4 + 0];
              var m31 = this._currentValue[3 * 4 + 1];
              var m32 = this._currentValue[3 * 4 + 2];
              var m33 = this._currentValue[3 * 4 + 3];
              var tmp0 = m22 * m33;
              var tmp1 = m32 * m23;
              var tmp2 = m12 * m33;
              var tmp3 = m32 * m13;
              var tmp4 = m12 * m23;
              var tmp5 = m22 * m13;
              var tmp6 = m02 * m33;
              var tmp7 = m32 * m03;
              var tmp8 = m02 * m23;
              var tmp9 = m22 * m03;
              var tmp10 = m02 * m13;
              var tmp11 = m12 * m03;
              var tmp12 = m20 * m31;
              var tmp13 = m30 * m21;
              var tmp14 = m10 * m31;
              var tmp15 = m30 * m11;
              var tmp16 = m10 * m21;
              var tmp17 = m20 * m11;
              var tmp18 = m00 * m31;
              var tmp19 = m30 * m01;
              var tmp20 = m00 * m21;
              var tmp21 = m20 * m01;
              var tmp22 = m00 * m11;
              var tmp23 = m10 * m01;
              var t0 = tmp0 * m11 + tmp3 * m21 + tmp4 * m31 - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
              var t1 = tmp1 * m01 + tmp6 * m21 + tmp9 * m31 - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
              var t2 = tmp2 * m01 + tmp7 * m11 + tmp10 * m31 - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
              var t3 = tmp5 * m01 + tmp8 * m11 + tmp11 * m21 - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
              var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
              this._currentValue = [d * t0, d * t1, d * t2, d * t3, d * (tmp1 * m10 + tmp2 * m20 + tmp5 * m30 - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)), d * (tmp0 * m00 + tmp7 * m20 + tmp8 * m30 - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)), d * (tmp3 * m00 + tmp6 * m10 + tmp11 * m30 - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)), d * (tmp4 * m00 + tmp9 * m10 + tmp10 * m20 - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)), d * (tmp12 * m13 + tmp15 * m23 + tmp16 * m33 - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)), d * (tmp13 * m03 + tmp18 * m23 + tmp21 * m33 - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)), d * (tmp14 * m03 + tmp19 * m13 + tmp22 * m33 - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)), d * (tmp17 * m03 + tmp20 * m13 + tmp23 * m23 - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)), d * (tmp14 * m22 + tmp17 * m32 + tmp13 * m12 - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)), d * (tmp20 * m32 + tmp12 * m02 + tmp19 * m22 - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)), d * (tmp18 * m12 + tmp23 * m32 + tmp15 * m02 - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)), d * (tmp22 * m22 + tmp16 * m02 + tmp21 * m12 - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02))];
          }
      }, {
          key: 'transpose',
          value: function transpose() {
              // AKA swap the columns of a matrix for rows
              this._currentValue = [this._currentValue[0], this._currentValue[4], this._currentValue[8], this._currentValue[12], this._currentValue[1], this._currentValue[5], this._currentValue[9], this._currentValue[13], this._currentValue[2], this._currentValue[6], this._currentValue[10], this._currentValue[14], this._currentValue[3], this._currentValue[7], this._currentValue[11], this._currentValue[15]];
          }
      }, {
          key: 'value',
          get: function get$$1() {
              return this._currentValue;
          },
          set: function set$$1(value) {
              this._currentValue = value;
          }
      }]);
      return Matrix4;
  }();

  // A 16 x 16 checked placeholder texture
  var defaultTexture = function () {
      var texture = new Uint8Array(4 * 16 * 16);
      for (var i = 0; i < 16; i++) {
          for (var j = 0; j < 16; j++) {
              var offset = 64 * i + 4 * j;
              // If this is the bottom left or top right square of the 4 square check, color is grey
              // Otherwise the color should be white
              var color = i < 8 && j < 8 || i >= 8 && j >= 8 ? 150 : 255;
              texture[offset] = color; // r
              texture[offset + 1] = color; // g
              texture[offset + 2] = color; // b
              texture[offset + 3] = 255; // alpha
          }
      }
      return texture;
  }();

  var World = function () {
      function World(canvasId) {
          var _this = this;

          classCallCheck(this, World);

          this._previousRenderTime = 0;
          this._update = function (renderTime) {
              // Convert from milliseconds to seconds
              renderTime *= 0.001;
              // Get the elapsed time
              var timePassed = renderTime - _this._previousRenderTime;
              // Store previous render time
              _this._previousRenderTime = renderTime;
              // Allow for updates to take place before updating camera matrix
              // This ensures the whole scene remains on the same frame
              if (_this._onUpdate) _this._onUpdate(timePassed);
              if (_this._activeScene) _this._activeScene.update();
              // Draw all children in current scene
              _this._draw();
              // Wait for next frame
              _this._startFrameTimer();
          };
          this._onMeshAddedToScene = function (newChild) {
              _this._processMeshMaterial(newChild);
          };
          this._onMeshMaterialUpdated = function (child) {
              _this._processMeshMaterial(child);
          };
          this._onCameraAdded = function (camera) {
              _this._activeScene.resize(_this._canvas.clientWidth, _this._canvas.clientHeight);
          };
          this._onImageLoadComplete = function (material) {
              _this._gl.bindTexture(_this._gl.TEXTURE_2D, material.texture);
              // TODO: Allow the texture filtering to be selectable
              _this._gl.texParameteri(_this._gl.TEXTURE_2D, _this._gl.TEXTURE_MIN_FILTER, _this._gl.LINEAR);
              _this._gl.texParameteri(_this._gl.TEXTURE_2D, _this._gl.TEXTURE_MAG_FILTER, _this._gl.LINEAR);
              _this._gl.texImage2D(_this._gl.TEXTURE_2D, 0, _this._gl.RGBA, _this._gl.RGBA, _this._gl.UNSIGNED_BYTE, material.image);
              _this._gl.generateMipmap(_this._gl.TEXTURE_2D);
          };
          this._onWindowResized = function () {
              if (!_this._resizeFrameRequest) {
                  _this._resizeFrameRequest = requestAnimationFrame(_this._onFrameTimerTicked);
              }
          };
          this._onFrameTimerTicked = function () {
              _this._resizeCanvas();
          };
          this._canvas = document.getElementById(canvasId);
          this._initGL();
          this._addListeners();
          this._onWindowResized();
      }

      createClass(World, [{
          key: '_initGL',
          value: function _initGL() {
              this._gl = this._canvas.getContext('webgl2');
              if (!this._gl) throw new Error('World: Failed to instantiate a WebGL2 context');
              this._vao = this._gl.createVertexArray();
              this._gl.bindVertexArray(this._vao);
              // Don't render back-facing triangles
              this._gl.enable(this._gl.CULL_FACE);
              // Enable depth buffer (ie. don't show obscured pixels)
              this._gl.enable(this._gl.DEPTH_TEST);
              this._createBuffers();
          }
      }, {
          key: '_createBuffers',
          value: function _createBuffers() {
              this._positionBuffer = this._gl.createBuffer();
              this._normalsBuffer = this._gl.createBuffer();
              this._indexBuffer = this._gl.createBuffer();
              this._uvBuffer = this._gl.createBuffer();
          }
      }, {
          key: '_addListeners',
          value: function _addListeners() {
              window.addEventListener('resize', this._onWindowResized);
          }
      }, {
          key: '_resizeCanvas',
          value: function _resizeCanvas() {
              this._resizeFrameRequest = undefined;
              var cssToRealPixels = window.devicePixelRatio || 1;
              var displayWidth = Math.floor(this._canvas.clientWidth * cssToRealPixels);
              var displayHeight = Math.floor(this._canvas.clientHeight * cssToRealPixels);
              if (this._canvas.width !== displayWidth || this._canvas.height !== displayHeight) {
                  this._canvas.width = displayWidth;
                  this._canvas.height = displayHeight;
              }
              this._gl.viewport(0, 0, displayWidth, displayHeight);
              if (this._activeScene && this._activeScene.camera) {
                  this._activeScene.resize(displayWidth, displayHeight);
              }
          }
      }, {
          key: '_startFrameTimer',
          value: function _startFrameTimer() {
              this._clearFrameTimer();
              this._frameTimer = requestAnimationFrame(this._update);
          }
      }, {
          key: '_clearFrameTimer',
          value: function _clearFrameTimer() {
              if (this._frameTimer) {
                  cancelAnimationFrame(this._frameTimer);
                  this._frameTimer = undefined;
              }
          }
      }, {
          key: '_processMeshMaterial',
          value: function _processMeshMaterial(mesh) {
              if (!mesh.material.program) {
                  // Instantiate the material as required
                  mesh.material.program = new Program(this._gl, mesh.material.vertexShader, mesh.material.fragmentShader);
                  if (mesh.material.isTextureMap && !mesh.material.texture) {
                      // Prepare the texture
                      this._prepareMaterialTexture(mesh.material);
                  }
              }
          }
      }, {
          key: '_prepareMaterialTexture',
          value: function _prepareMaterialTexture(material) {
              var texture = this._gl.createTexture();
              material.texture = texture;
              this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
              this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, 16, 16, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, defaultTexture);
              this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.REPEAT);
              this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.REPEAT);
              this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
              this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
              material.loadImage(this._onImageLoadComplete);
          }
      }, {
          key: '_draw',
          value: function _draw() {
              var _this2 = this;

              this._gl.clearColor(0.7, 0.7, 0.7, 1);
              this._gl.clear(this._gl.COLOR_BUFFER_BIT);
              var sceneCamera = this._activeScene.camera;
              if (!sceneCamera) return;
              var sceneCameraMatrix = this._activeScene.camera.matrix;
              var meshes = this._activeScene.children;
              meshes.forEach(function (mesh) {
                  var program = mesh.material.program;
                  if (program) {
                      // Use the correct shader for this mesh
                      _this2._gl.useProgram(program.glProgram);
                      // Mesh matrix
                      var meshMatrix = new Matrix4(sceneCameraMatrix);
                      meshMatrix.multiply(mesh.matrix);
                      _this2._gl.uniformMatrix4fv(program.matrixUniform, false, meshMatrix.value);
                      // Normals matrix
                      // Protect the normals from world scaling by inverting and transposing the mesh's matrix
                      var normalsMatrix = new Matrix4(mesh.normalsMatrix);
                      normalsMatrix.invert();
                      normalsMatrix.transpose();
                      _this2._gl.uniformMatrix4fv(program.normalMatrixUniform, false, normalsMatrix.value);
                      // Normals
                      _this2._gl.bindBuffer(_this2._gl.ARRAY_BUFFER, _this2._normalsBuffer);
                      _this2._gl.enableVertexAttribArray(program.normalAttribute);
                      _this2._gl.vertexAttribPointer(program.normalAttribute, 3, _this2._gl.FLOAT, false, 0, 0);
                      _this2._gl.bufferData(_this2._gl.ARRAY_BUFFER, mesh.normals, _this2._gl.STATIC_DRAW);
                      // Vertices
                      _this2._gl.bindBuffer(_this2._gl.ARRAY_BUFFER, _this2._positionBuffer);
                      _this2._gl.enableVertexAttribArray(program.positionAttribute);
                      _this2._gl.vertexAttribPointer(program.positionAttribute, 3, _this2._gl.FLOAT, false, 0, 0);
                      _this2._gl.bufferData(_this2._gl.ARRAY_BUFFER, mesh.vertices, _this2._gl.STATIC_DRAW);
                      // Indices
                      _this2._gl.bindBuffer(_this2._gl.ELEMENT_ARRAY_BUFFER, _this2._indexBuffer);
                      _this2._gl.bufferData(_this2._gl.ELEMENT_ARRAY_BUFFER, mesh.indices, _this2._gl.STATIC_DRAW);
                      // UVs / Material texture
                      if (program.uvAttribute && program.uvAttribute !== -1 && mesh.uvs.length && mesh.material.isTextureMap) {
                          _this2._gl.bindTexture(_this2._gl.TEXTURE_2D, mesh.material.texture);
                          _this2._gl.bindBuffer(_this2._gl.ARRAY_BUFFER, _this2._uvBuffer);
                          _this2._gl.enableVertexAttribArray(program.uvAttribute);
                          _this2._gl.vertexAttribPointer(program.uvAttribute, 2, _this2._gl.FLOAT, true, 0, 0);
                          _this2._gl.bufferData(_this2._gl.ARRAY_BUFFER, mesh.uvs, _this2._gl.STATIC_DRAW);
                      }
                      _this2._gl.drawElements(_this2._gl.TRIANGLES, mesh.indices.length, _this2._gl.UNSIGNED_SHORT, 0);
                      // Material color
                      if (program.colorUniform) {
                          _this2._gl.uniform4fv(program.colorUniform, [mesh.material.colorInUnits.r, mesh.material.colorInUnits.g, mesh.material.colorInUnits.b, mesh.material.colorInUnits.a]);
                      }
                      // Lights
                      var lightValues = { x: 0, y: 0, z: 0 };
                      var lightColor = [0, 0, 0];
                      var directionalLight = _this2._activeScene.directionalLight;
                      if (directionalLight) {
                          lightValues = directionalLight.direction;
                          lightColor = directionalLight.colorInUnits;
                      }
                      var normalizedLightValues = normalizeVector(lightValues);
                      _this2._gl.uniform3fv(program.lightDirectionUniform, [normalizedLightValues.x, normalizedLightValues.y, normalizedLightValues.z]);
                      _this2._gl.uniform3fv(program.lightColorUniform, lightColor);
                  } else {
                      throw new Error('Mesh ' + mesh.id + ' has no material assigned, so will not be rendered');
                  }
              });
          }
      }, {
          key: 'scene',
          set: function set$$1(scene) {
              var _this3 = this;

              if (!(scene instanceof Scene)) {
                  throw new Error('Cannot set scene, as it is not a valid Scene reference');
              }
              this._activeScene = scene;
              this._activeScene.onChildAdded = this._onMeshAddedToScene;
              this._activeScene.onMeshMaterialUpdated = this._onMeshMaterialUpdated;
              this._activeScene.onCameraAdded = this._onCameraAdded;
              if (scene.camera) this._onCameraAdded(scene.camera);
              if (scene.children.length) {
                  scene.children.forEach(function (mesh) {
                      _this3._onMeshAddedToScene(mesh);
                  });
              }
          }
      }, {
          key: 'onUpdate',
          set: function set$$1(callback) {
              this._onUpdate = callback;
              if (callback) {
                  this._startFrameTimer();
              } else {
                  this._clearFrameTimer();
              }
          }
      }]);
      return World;
  }();

  var easing = {
      linear: { x1: 0, t1: 0, x2: 1, t2: 1 },
      inSine: { x1: 0.47, t1: 0.0, x2: 0.745, t2: 0.715 },
      outSine: { x1: 0.39, t1: 0.575, x2: 0.565, t2: 1 },
      inOutSine: { x1: 0.445, t1: 0.05, x2: 0.55, t2: 0.95 },
      inQuad: { x1: 0.55, t1: 0.085, x2: 0.68, t2: 0.53 },
      outQuad: { x1: 0.25, t1: 0.46, x2: 0.45, t2: 0.94 },
      inOutQuad: { x1: 0.455, t1: 0.03, x2: 0.515, t2: 0.955 },
      inCubic: { x1: 0.55, t1: 0.055, x2: 0.675, t2: 0.19 },
      outCubic: { x1: 0.215, t1: 0.61, x2: 0.355, t2: 1 },
      inOutCubic: { x1: 0.645, t1: 0.045, x2: 0.355, t2: 1 },
      inQuart: { x1: 0.895, t1: 0.03, x2: 0.685, t2: 0.22 },
      outQuart: { x1: 0.165, t1: 0.84, x2: 0.44, t2: 1 },
      inOutQuart: { x1: 0.77, t1: 0, x2: 0.175, t2: 1 },
      inQuint: { x1: 0.755, t1: 0.05, x2: 0.855, t2: 0.06 },
      outQuint: { x1: 0.23, t1: 1, x2: 0.32, t2: 1 },
      inOutQuint: { x1: 0.86, t1: 0, x2: 0.07, t2: 1 },
      inExpo: { x1: 0.95, t1: 0.05, x2: 0.795, t2: 0.035 },
      outExpo: { x1: 0.19, t1: 1, x2: 0.22, t2: 1 },
      inOutExpo: { x1: 1, t1: 0, x2: 0, t2: 1 },
      inCirc: { x1: 0.6, t1: 0.04, x2: 0.98, t2: 0.335 },
      outCirc: { x1: 0.075, t1: 0.82, x2: 0.165, t2: 1 },
      inOutCirc: { x1: 0.785, t1: 0.135, x2: 0.15, t2: 0.86 },
      inBack: { x1: 0.6, t1: -0.28, x2: 0.735, t2: 0.045 },
      outBack: { x1: 0.175, t1: 0.885, x2: 0.32, t2: 1.275 },
      inOutBack: { x1: 0.68, t1: -0.55, x2: 0.265, t2: 1.55 }
  };

  var degreesToRadians = function degreesToRadians(angleInDegrees) {
      return angleInDegrees * Math.PI / 180;
  };
  var radiansToDegrees = function radiansToDegrees(angleInRadians) {
      return angleInRadians * 180 / Math.PI;
  };

  var colorType;
  (function (colorType) {
      colorType[colorType["hex"] = 0] = "hex";
      colorType[colorType["rgb"] = 1] = "rgb";
      colorType[colorType["rgba"] = 2] = "rgba";
      colorType[colorType["hsl"] = 3] = "hsl";
      colorType[colorType["hsla"] = 4] = "hsla";
  })(colorType || (colorType = {}));

  var convertColorToUnits = function convertColorToUnits(color) {
      return {
          r: color.r / 255,
          g: color.g / 255,
          b: color.b / 255,
          a: color['a'] || 1
      };
  };
  var getColorType = function getColorType(color) {
      if ((typeof color === 'undefined' ? 'undefined' : _typeof(color)) === 'object') {
          if (color.r && color.g && color.b) {
              return color.a ? colorType.rgba : colorType.rgb;
          } else if (color.h && color.s && color.l) {
              return color.a ? colorType.hsla : colorType.hsl;
          } else {
              return undefined;
          }
      } else if (typeof color === 'string') {
          if (validHex(color)) return colorType.hex;
          if (validRGB(color)) return colorType.rgb;
          if (validRGBA(color)) return colorType.rgba;
          if (validHSL(color)) return colorType.hsl;
          if (validHSLA(color)) return colorType.hsla;
          return undefined;
      } else {
          return undefined;
      }
  };
  var validHex = function validHex(color) {
      color = expandHex(color);
      return (/^#[0-9A-F]{6}$/i.test(color)
      );
  };
  var validRGB = function validRGB(color) {
      return (/^(rgb)?\(?([01]?\d\d?|2[0-4]\d|25[0-5])(\W+)([01]?\d\d?|2[0-4]\d|25[0-5])\W+(([01]?\d\d?|2[0-4]\d|25[0-5])\)?)$/i.test(color)
      );
  };
  var validRGBA = function validRGBA(color) {
      return (/^rgba\(\s*(-?\d+|-?\d*\.\d+(?=%))(%?)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)$/i.test(color)
      );
  };
  var validHSL = function validHSL(color) {
      return (/^hsl\((\d+(\.\d)*)(turn|rad)*,\s*([\d.]+)%,\s*([\d.]+)%\)$/i.test(color)
      );
  };
  var validHSLA = function validHSLA(color) {
      return (/hsla\((\d+(\.\d)*)(turn|rad)*,\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d+(?:\.\d+)?)\)/i.test(color)
      );
  };
  var expandHex = function expandHex(color) {
      if (color.length === 4) {
          color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
      }
      return color;
  };
  var convertToRGBA = function convertToRGBA(color, type) {
      if (type === colorType.rgb) {
          return rgbToRGBA(color);
      } else if (type === colorType.rgba) {
          return color;
      } else if (type === colorType.hex) {
          return hexToRGBA(color);
      } else if (type === colorType.hsl || type === colorType.hsla) {
          return hslToRGBA(color);
      } else {
          return undefined;
      }
  };
  var rgbToRGBA = function rgbToRGBA(color) {
      if (typeof color === 'string' && validRGB(color)) {
          color = color.replace('rgb', 'rgba');
          color = color.replace(')', ', 1)');
      }
      return color;
  };
  var hexToRGBA = function hexToRGBA(color) {
      var colorArray = void 0;
      var newColorValue = void 0;
      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(color)) {
          colorArray = color.substring(1).split('');
          // handle short hex like #0FF
          if (colorArray.length === 3) {
              colorArray = [colorArray[0], colorArray[0], colorArray[1], colorArray[1], colorArray[2], colorArray[2]];
          }
          newColorValue = '0x' + colorArray.join('');
          return 'rgba(' + [newColorValue >> 16 & 255, newColorValue >> 8 & 255, newColorValue & 255].join(',') + ', 1)';
      }
      throw new Error('colorUtils.hexToRGBA: Invalid hex color');
  };
  var hslToRGBA = function hslToRGBA(color) {
      var newColor = color.replace('hsla(', '');
      newColor = newColor.replace(/%|deg/g, '');
      newColor = newColor.replace('hsl(', '');
      newColor = newColor.replace(')', '');
      var colorArray = newColor.split(',');
      var h = colorArray[0];
      if (h !== '0') {
          // Check for radians or turns as units
          if (h.search('rad') > -1) {
              h = radiansToDegrees(parseFloat(h.replace('rad', '')));
          } else if (h.search('turn') > -1) {
              h = parseFloat(h.replace('turn', '')) * 360;
          }
      }
      h = parseFloat(h) / 360;
      var s = parseFloat(colorArray[1]) / 100;
      var l = parseFloat(colorArray[2]) / 100;
      var a = colorArray[3] ? parseFloat(colorArray[3]) : 1;
      var r = void 0;
      var g = void 0;
      var b = void 0;
      if (s === 0) {
          r = g = b = 0;
      } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hueToRGB(p, q, h + 1 / 3) * 255;
          g = hueToRGB(p, q, h) * 255;
          b = hueToRGB(p, q, h - 1 / 3) * 255;
      }
      return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
  };
  var hueToRGB = function hueToRGB(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
  };
  var getColorBetweenRGBA = function getColorBetweenRGBA(start, end, percentage) {
      var startValues = getColorValuesFromRGBAString(start);
      var endValues = getColorValuesFromRGBAString(end);
      ['r', 'g', 'b', 'a'].forEach(function (value) {
          startValues[value] = parseFloat(startValues[value]);
          endValues[value] = parseFloat(endValues[value]);
      });
      var r = Math.round(startValues.r + (endValues.r - startValues.r) * percentage);
      var g = Math.round(startValues.g + (endValues.g - startValues.g) * percentage);
      var b = Math.round(startValues.b + (endValues.b - startValues.b) * percentage);
      var a = startValues.a + (endValues.a - startValues.a) * percentage;
      return { r: r, g: g, b: b, a: a };
      /*return Oomph3D.motion.outputColorsAsStrings
        ? `rgba(${r}, ${g}, ${b}, ${a})`
        : {r, g, b, a};*/
  };
  var getColorValuesFromRGBAString = function getColorValuesFromRGBAString(color) {
      color = color.replace(/ |rgba\(|rgb\(|, |,|\)/, '');
      var colorArray = color.split(',');
      var r = colorArray[0];
      var g = colorArray[1];
      var b = colorArray[2];
      if (r.search('%') > -1) r = parseInt(r, 10) / 100 * 255;
      if (g.search('%') > -1) g = parseInt(g, 10) / 100 * 255;
      if (b.search('%') > -1) b = parseInt(b, 10) / 100 * 255;
      return {
          r: Math.round(r),
          g: Math.round(g),
          b: Math.round(b),
          a: colorArray[3] ? parseFloat(colorArray[3]) : 1
      };
  };

  var getEasedPercentageOnCurve = function getEasedPercentageOnCurve(bezierObject, percentage) {
      // If the ease is linear, return the percentage as is
      if (bezierObject.x1 === bezierObject.t1 && bezierObject.x2 === bezierObject.t2) return percentage;
      return calculateBezier(getPositionOnCurve(bezierObject, percentage), bezierObject.t1, bezierObject.t2);
  };
  var getPositionOnCurve = function getPositionOnCurve(bezierObject, percentage) {
      // Newton method of guessing the position through iterations
      var bezierGuess = percentage;
      var currentBezierSlope = 0;
      var currentBezierX = 0;
      var iterations = 30;
      for (var i = 0; i < iterations; i++) {
          currentBezierSlope = getBezierSlope(bezierGuess, bezierObject.x1, bezierObject.x2);
          if (currentBezierSlope === 0.0) return bezierGuess;
          currentBezierX = calculateBezier(bezierGuess, bezierObject.x1, bezierObject.x2) - percentage;
          bezierGuess -= currentBezierX / currentBezierSlope;
      }
      return bezierGuess;
  };
  var getBezierSlope = function getBezierSlope(guess, start, end) {
      return 3.0 * (1.0 - 3.0 * end + 3.0 * start) * guess * guess + 2.0 * (3.0 * end - 6.0 * start) * guess + 3.0 * start;
  };
  var calculateBezier = function calculateBezier(guess, start, end) {
      return (((1.0 - 3.0 * end + 3.0 * start) * guess + (3.0 * end - 6.0 * start)) * guess + 3.0 * start) * guess;
  };

  var ActiveAnimation = function () {
      function ActiveAnimation(source, destination, options, info) {
          classCallCheck(this, ActiveAnimation);

          this._elapsedSinceStart = 0;
          this._waitingForDelay = false;
          this._complete = false;
          this._loopCount = 0;
          this._totalLoops = 0;
          this._animBackwards = false;
          this._paused = false;
          this._elapsedWhenPaused = 0;
          this._progress = 0;
          this._easedProgress = 0;
          this._source = source;
          this._destination = destination;
          this._options = options;
          this._info = info;
          this._startValues = source;
          this._endValues = destination;
          this._currentValues = this._startValues;
          this._id = Math.random() + Date.now();
          this._endTime = options.duration;
          this._waitingForDelay = !!this._options.delay;
          this._totalLoops = typeof options.loops === 'number' ? options.loops : undefined;
          this._processValues();
      }

      createClass(ActiveAnimation, [{
          key: 'stop',
          value: function stop() {
              this._animBackwards = false;
              this.reset();
          }
      }, {
          key: 'pause',
          value: function pause() {
              if (!this._paused) {
                  this._paused = true;
                  this._elapsedWhenPaused = this._elapsedSinceStart;
              }
          }
      }, {
          key: 'resume',
          value: function resume() {
              if (this._paused) {
                  this._paused = false;
                  // Resume at the correct progress
                  this._elapsedSinceStart = this._elapsedWhenPaused;
              }
          }
      }, {
          key: 'reset',
          value: function reset() {
              this.restart();
              this.update(0);
          }
      }, {
          key: 'updateStartValues',
          value: function updateStartValues(values) {
              if (!this._info.isNumber && !this._info.isColor && !this._info.isNumberArray) {
                  // Properties of an object instead of a raw number or color
                  for (var key in values) {
                      if (this._startValues[key]) {
                          this._startValues[key] = values[key];
                      }
                  }
              } else {
                  this._startValues = values;
              }
          }
      }, {
          key: 'updateEndValues',
          value: function updateEndValues(values) {
              if (!this._info.isNumber && !this._info.isColor && !this._info.isNumberArray) {
                  // Properties of an object instead of a raw number or color
                  for (var key in values) {
                      if (this._endValues[key]) {
                          this._endValues[key] = values[key];
                      }
                  }
              } else {
                  this._endValues = values;
              }
          }
      }, {
          key: 'update',
          value: function update(elapsed) {
              this._elapsedSinceStart += elapsed;
              if (this._waitingForDelay) {
                  if (this._options.delay && this._elapsedSinceStart < this._options.delay) {
                      return;
                  }
                  this._elapsedSinceStart -= this._options.delay;
                  this._waitingForDelay = false;
              }
              if (!this._paused) {
                  if (this._options.steps) {
                      var stepDuration = this._options.duration / (this._options.steps - 1);
                      var currentStep = Math.floor(this._elapsedSinceStart / stepDuration);
                      if (this._animBackwards) {
                          currentStep = this._options.steps - 1 - currentStep;
                      }
                      this._progress = currentStep / (this._options.steps - 1);
                  } else {
                      this._progress = Math.min(this._elapsedSinceStart / this._options.duration, 1);
                      if (this._animBackwards) this._progress = 1 - this._progress;
                  }
                  if (this._progress > 1) {
                      this._progress = 1;
                  } else if (this._progress < 0) {
                      this._progress = 0;
                  }
                  this._easedProgress = getEasedPercentageOnCurve(this._options.easing, this._progress);
                  if (this._info.isNumber) {
                      this._updateNumberValue();
                  } else if (this._info.isColor) {
                      this._updateColorValue();
                  } else if (this._info.isNumberArray) {
                      this._updateNumberArrayValue();
                  } else {
                      this._updateObjectValues();
                  }
                  if (this._options.onUpdate) this._options.onUpdate({
                      id: this._id,
                      source: this._source,
                      value: this._currentValues,
                      progress: this._progress
                  });
                  if (this._progress === 1 && !this._animBackwards || this._progress === 0 && this._animBackwards) {
                      if (this._options.loops) {
                          this._loopCount++;
                          if (this._totalLoops && this._loopCount >= this._totalLoops) {
                              this._complete = true;
                              if (this._options.onComplete) this._options.onComplete();
                          } else {
                              this.restart();
                          }
                      } else if (this._options.alternate) {
                          this.reverseDirection();
                      } else if (this._options.bounce) {
                          this.reverseEasing();
                      } else {
                          this._complete = true;
                          if (this._options.onComplete) this._options.onComplete();
                      }
                  }
              }
          }
      }, {
          key: 'restart',
          value: function restart() {
              this._complete = false;
              this._progress = 0;
              this._easedProgress = 0;
              this._elapsedSinceStart = 0;
          }
      }, {
          key: 'reverseEasing',
          value: function reverseEasing() {
              this.restart();
              this._animBackwards = !this._animBackwards;
          }
      }, {
          key: 'reverseDirection',
          value: function reverseDirection() {
              this.restart();
              var newStartValues = this._endValues;
              this._endValues = this._startValues;
              this._startValues = newStartValues;
          }
      }, {
          key: '_processValues',
          value: function _processValues() {
              var _this = this;

              if (!this._info.isNumber && !this._info.isColor && !this._info.isNumberArray) {
                  // Properties of an object instead of a raw number or color
                  this._startValues = {};
                  Object.keys(this._destination).forEach(function (key) {
                      var startValue = _this._source[key];
                      var endValue = _this._destination[key];
                      var valueData = _this._prepareStartAndEndValue(startValue, endValue);
                      _this._startValues[key] = {
                          value: valueData.start,
                          isNumberArray: Array.isArray(valueData.start),
                          isColor: valueData.isColor,
                          colorType: valueData.startColorType
                      };
                      _this._endValues[key] = {
                          value: valueData.end,
                          isNumberArray: Array.isArray(valueData.end),
                          isColor: valueData.isColor,
                          colorType: valueData.endColorType
                      };
                      _this._currentValues[key] = valueData.start;
                  });
              } else {
                  // Either a raw number or a raw color string
                  var valueData = this._prepareStartAndEndValue(this._startValues, this._endValues);
                  this._startValues = valueData.start;
                  this._endValues = valueData.end;
              }
          }
      }, {
          key: '_prepareStartAndEndValue',
          value: function _prepareStartAndEndValue(startValue, endValue) {
              var isColor = this._info.sourceColorType >= 0 && this._info.destColorType >= 0;
              if (isColor) {
                  var startType = getColorType(startValue);
                  var endType = getColorType(endValue);
                  startValue = convertToRGBA(startValue, startType);
                  endValue = convertToRGBA(endValue, endType);
              }
              return {
                  start: startValue,
                  end: endValue,
                  isColor: isColor,
                  startColorType: this._info.sourceColorType,
                  endColorType: this._info.destColorType
              };
          }
      }, {
          key: '_updateNumberValue',
          value: function _updateNumberValue() {
              this._currentValues = this._startValues + this._easedProgress * (this._endValues - this._startValues);
          }
      }, {
          key: '_updateColorValue',
          value: function _updateColorValue() {
              this._currentValues = getColorBetweenRGBA(this._startValues, this._endValues, this._easedProgress);
          }
      }, {
          key: '_updateNumberArrayValue',
          value: function _updateNumberArrayValue() {
              this._currentValues = [];
              for (var i = 0; i < this._endValues.length; i++) {
                  this._currentValues.push(this._startValues[i] + this._easedProgress * (this._endValues[i] - this._startValues[i]));
              }
          }
      }, {
          key: '_updateObjectValues',
          value: function _updateObjectValues() {
              var _this2 = this;

              Object.keys(this._endValues).forEach(function (key) {
                  var newValue = void 0;
                  if (_this2._startValues[key].isColor) {
                      newValue = getColorBetweenRGBA(_this2._startValues[key].value, _this2._endValues[key].value, _this2._easedProgress);
                  } else if (_this2._startValues[key].isNumberArray) {
                      newValue = [];
                      for (var i = 0; i < _this2._endValues[key].value.length; i++) {
                          newValue.push(_this2._startValues[key].value[i] + _this2._easedProgress * (_this2._endValues[key].value[i] - _this2._startValues[key].value[i]));
                      }
                  } else {
                      // If the value itself is an object, update each key of that value separately
                      if (_typeof(_this2._endValues[key].value) === 'object') {
                          newValue = {};
                          Object.keys(_this2._endValues[key].value).forEach(function (subKey) {
                              newValue[subKey] = _this2._startValues[key].value[subKey] + _this2._easedProgress * (_this2._endValues[key].value[subKey] - _this2._startValues[key].value[subKey]);
                          });
                      } else {
                          newValue = _this2._startValues[key].value + _this2._easedProgress * (_this2._endValues[key].value - _this2._startValues[key].value);
                      }
                  }
                  _this2._source[key] = newValue;
                  _this2._currentValues[key] = newValue;
              });
          }
      }, {
          key: 'id',
          get: function get$$1() {
              return this._id;
          }
      }, {
          key: 'complete',
          get: function get$$1() {
              return this._complete;
          }
      }, {
          key: 'value',
          get: function get$$1() {
              return this._currentValues;
          }
      }, {
          key: 'paused',
          get: function get$$1() {
              return this._paused;
          }
      }, {
          key: 'startValues',
          get: function get$$1() {
              return this._startValues;
          }
      }, {
          key: 'endValues',
          get: function get$$1() {
              return this._endValues;
          }
      }, {
          key: 'source',
          get: function get$$1() {
              return this._source;
          }
      }, {
          key: 'currentValue',
          get: function get$$1() {
              return this._currentValues;
          }
      }, {
          key: 'progress',
          get: function get$$1() {
              return this._progress;
          }
      }]);
      return ActiveAnimation;
  }();

  var Timeline = function () {
      function Timeline(source, newAnimations, options) {
          classCallCheck(this, Timeline);

          this._activeAnimationIndex = 0;
          this._complete = false;
          this._reversing = false;
          this._loopCount = 0;
          this._totalLoops = undefined;
          this._id = Math.random() + Date.now();
          this._source = source;
          this._animations = newAnimations;
          this._options = options || {};
          this._activeAnimation = newAnimations[0];
          this._totalLoops = typeof options.loops === 'number' ? options.loops : undefined;
      }

      createClass(Timeline, [{
          key: 'stop',
          value: function stop() {
              this._activeAnimation.stop();
          }
      }, {
          key: 'pause',
          value: function pause() {
              this._activeAnimation.pause();
          }
      }, {
          key: 'resume',
          value: function resume() {
              this._activeAnimation.resume();
          }
      }, {
          key: 'update',
          value: function update(elapsed) {
              if (this._activeAnimation.complete) {
                  var totalAnims = this._animations.length;
                  if (!this._reversing && this._activeAnimationIndex < totalAnims - 1) {
                      var previousEndValues = this._animations[this._activeAnimationIndex].endValues;
                      this._activeAnimationIndex++;
                      this._updateStartValues(previousEndValues);
                      this._activeAnimation = this._animations[this._activeAnimationIndex];
                  } else if (this._reversing && this._activeAnimationIndex > 0) {
                      var previousStartValues = this._animations[this._activeAnimationIndex].startValues;
                      this._activeAnimationIndex--;
                      this._updateEndValues(previousStartValues);
                      this._activeAnimation = this._animations[this._activeAnimationIndex];
                  } else {
                      this._onTimelineComplete();
                      return;
                  }
              }
              this._activeAnimation.update(elapsed);
              if (this._options.onUpdate) {
                  this._options.onUpdate({
                      id: this._activeAnimation.id,
                      source: this._activeAnimation.source,
                      value: this._activeAnimation.currentValue,
                      progress: this._activeAnimation.progress
                  });
              }
          }
      }, {
          key: '_updateStartValues',
          value: function _updateStartValues(previousEndValues) {
              for (var i = this._activeAnimationIndex; i < this._animations.length; i++) {
                  this._animations[i].updateStartValues(previousEndValues);
              }
          }
      }, {
          key: '_updateEndValues',
          value: function _updateEndValues(previousStartValues) {
              for (var i = this._activeAnimationIndex; i > 0; i--) {
                  this._animations[i].updateEndValues(previousStartValues);
              }
          }
      }, {
          key: '_restart',
          value: function _restart() {
              for (var i = this._animations.length - 1; i >= 0; i--) {
                  this._animations[i].restart();
              }
              var previousEndValues = this._animations.length > 1 ? this._animations[this._activeAnimationIndex].endValues : this._animations[0].startValues;
              this._updateStartValues(previousEndValues);
              this._activeAnimation = this._animations[0];
              this._activeAnimationIndex = 0;
          }
      }, {
          key: '_reverseDirection',
          value: function _reverseDirection() {
              this._reversing = !this._reversing;
              for (var i = this._animations.length - 1; i >= 0; i--) {
                  this._animations[i].reverseDirection();
              }
          }
      }, {
          key: '_reverseEasing',
          value: function _reverseEasing() {
              this._reversing = !this._reversing;
              for (var i = this._animations.length - 1; i >= 0; i--) {
                  this._animations[i].reverseEasing();
              }
          }
      }, {
          key: '_onTimelineComplete',
          value: function _onTimelineComplete() {
              if (this._options.loops) {
                  this._loopCount++;
                  if (this._totalLoops && this._loopCount >= this._totalLoops) {
                      this._complete = true;
                      if (this._options.onComplete) this._options.onComplete();
                  } else {
                      this._restart();
                  }
              } else if (this._options.alternate) {
                  this._reverseDirection();
              } else if (this._options.bounce) {
                  this._reverseEasing();
              } else if (this._options.onComplete) {
                  this._complete = true;
                  if (this._options.onComplete) this._options.onComplete();
              }
          }
      }, {
          key: 'id',
          get: function get$$1() {
              return this._id;
          }
      }, {
          key: 'complete',
          get: function get$$1() {
              return this._complete;
          }
      }]);
      return Timeline;
  }();

  var MotionCore = function () {
      function MotionCore() {
          classCallCheck(this, MotionCore);

          this._defaultEasing = easing.linear;
          this._defaultDuration = 1000;
          this._requestStartTime = 0;
          this._outputColorsAsStrings = false;
          this._activeAnimations = [];
      }

      createClass(MotionCore, [{
          key: 'start',

          /**
           * Start a new animation of properties
           * @param {object} target
           * @param {object} options The following options can be set:
           * to: Number, color, array of numbers, or object with values to animate towards
           * duration: Length of the animation in milliseconds
           * easing: Easing curve to use (x1, y1, x2, y2)
           * loops: Play the same animation infinitely
           * alternate: Animate back and forth, with the easing method the same in either direction
           * bounce: Animate back and forth, with the easing method reversed on return
           * steps: Jump between the passed number of steps instead of a smooth progression
           * onUpdate: Called every time the animation is updated. Passes the ActiveAnimation in the callback
           * onComplete: Called when the animation completes
           */
          value: function start(source, options) {
              if (!options.to) {
                  throw new Error('Motion: No value for \'to\' has been set');
              }
              var newAnimation = this._createAnimation(source, options);
              if (newAnimation) {
                  this._activeAnimations.push(newAnimation);
                  return newAnimation.id;
              } else {
                  return;
              }
          }
      }, {
          key: 'stop',
          value: function stop(id) {
              var remainingAnimations = [];
              for (var i = 0; i < this._activeAnimations.length; i++) {
                  if (this._activeAnimations[i].id === id || !id) {
                      this._activeAnimations[i].stop();
                  } else {
                      remainingAnimations.push(this._activeAnimations[i]);
                  }
              }
              this._activeAnimations = remainingAnimations;
          }
      }, {
          key: 'timeline',
          value: function timeline(source, animations, options) {
              var newAnimations = [];
              for (var i = 0; i < animations.length; i++) {
                  animations[i].loops = false;
                  animations[i].alternate = false;
                  animations[i].bounce = false;
                  newAnimations.push(this._createAnimation(source, animations[i]));
              }
              this._activeAnimations.push(new Timeline(source, newAnimations, options));
          }
      }, {
          key: 'pause',
          value: function pause(id) {
              for (var i = 0; i < this._activeAnimations.length; i++) {
                  if (this._activeAnimations[i].id === id || !id) {
                      this._activeAnimations[i].pause();
                  }
              }
          }
      }, {
          key: 'resume',
          value: function resume(id) {
              for (var i = 0; i < this._activeAnimations.length; i++) {
                  if (this._activeAnimations[i].id === id || !id) {
                      this._activeAnimations[i].resume();
                  }
              }
          }
      }, {
          key: '_createAnimation',
          value: function _createAnimation(source, options) {
              var destination = options.to;
              var sourceType = typeof source === 'undefined' ? 'undefined' : _typeof(source);
              var destType = typeof destination === 'undefined' ? 'undefined' : _typeof(destination);
              var sourceIsNumber = sourceType === 'number';
              var sourceColorType = getColorType(source);
              var sourceIsNumberArray = this._isNumberArray(source);
              if (sourceType !== 'object' && !sourceIsNumber && !sourceIsNumberArray && !sourceColorType) {
                  throw new Error('Motion: Start value is neither an object of values, a color, a number, or an array of numbers');
              }
              var destIsNumber = destType === 'number';
              var destColorType = getColorType(destination);
              var destIsNumberArray = this._isNumberArray(destination);
              if (destType !== 'object' && !destIsNumber && !destIsNumberArray && !destColorType) {
                  throw new Error('Motion: End value is neither an object of values, a color, a number, or an array of numbers');
              }
              if (sourceType !== destType || sourceIsNumberArray !== destIsNumberArray) {
                  throw new Error('Motion: Start and end value types don\'t match.');
              }
              var animationInfo = {
                  isNumber: sourceIsNumber && destIsNumber,
                  sourceColorType: sourceColorType,
                  destColorType: destColorType,
                  isColor: !!(sourceColorType && destColorType),
                  isNumberArray: sourceIsNumberArray && destIsNumberArray
              };
              options.easing = options.easing || this._defaultEasing;
              options.duration = options.duration || this._defaultDuration;
              if (!this._activeAnimations.length) {
                  // Start the animation loop if no animations are running
                  this._requestStartTime = 0;
                  this._startAnimFrameRequest();
              }
              return new ActiveAnimation(source, destination, options, animationInfo);
          }
      }, {
          key: '_startAnimFrameRequest',
          value: function _startAnimFrameRequest() {
              this._stopAnimFrameRequest();
              this._animFrame = requestAnimationFrame(this._onFrame.bind(this));
          }
      }, {
          key: '_stopAnimFrameRequest',
          value: function _stopAnimFrameRequest() {
              if (this._animFrame) {
                  cancelAnimationFrame(this._animFrame);
                  this._animFrame = undefined;
              }
          }
      }, {
          key: '_isNumberArray',
          value: function _isNumberArray(value) {
              var isArray = Array.isArray(value);
              if (!isArray) return false;
              for (var i = 0; i < value.length; i++) {
                  if (typeof value[i] !== 'number') return false;
              }
              return true;
          }
      }, {
          key: '_onFrame',
          value: function _onFrame(currentTime) {
              var elapsed = !this._requestStartTime ? 0 : currentTime - this._requestStartTime;
              this._requestStartTime = currentTime;
              for (var i = 0; i < this._activeAnimations.length; i++) {
                  this._activeAnimations[i].update(elapsed);
              }
              this._checkForCompletedAnimations();
              if (this._activeAnimations.length) {
                  this._startAnimFrameRequest();
              } else {
                  this._stopAnimFrameRequest();
              }
          }
      }, {
          key: '_checkForCompletedAnimations',
          value: function _checkForCompletedAnimations() {
              var incompleteAnims = [];
              for (var i = 0; i < this._activeAnimations.length; i++) {
                  if (!this._activeAnimations[i].complete) {
                      incompleteAnims.push(this._activeAnimations[i]);
                  }
              }
              this._activeAnimations = incompleteAnims;
          }
      }, {
          key: 'outputColorsAsStrings',
          get: function get$$1() {
              return this._outputColorsAsStrings;
          },
          set: function set$$1(value) {
              this._outputColorsAsStrings = value;
          }
      }, {
          key: 'easing',
          get: function get$$1() {
              return easing;
          }
      }]);
      return MotionCore;
  }();

  var Motion = new MotionCore();

  var Mesh = function () {
      function Mesh(options) {
          classCallCheck(this, Mesh);

          this._width = 0;
          this._height = 0;
          this._depth = 0;
          this._position = { x: 0, y: 0, z: 0 };
          this._rotation = { x: 0, y: 0, z: 0 };
          this._rotationRadians = { x: 0, y: 0, z: 0 };
          this._scale = { x: 1, y: 1, z: 1 };
          this._id = 'Mesh-' + Date.now();
          this._vertices = new Float32Array(options.vertices || []);
          this._normals = new Float32Array(options.normals || []);
          this._indices = new Uint16Array(options.indices || []);
          this._uvs = new Float32Array(options.uvs || []);
          this._material = options.material;
          this._matrix = new Matrix4();
          this._normalMatrix = new Matrix4();
          if (options.vertices) this._calculateBounds();
      }

      createClass(Mesh, [{
          key: '_updateMatrix',
          value: function _updateMatrix() {
              var scaledHeight = this._height * this._scale.y;
              var updatedMatrix = new Matrix4();
              updatedMatrix.translate(this._position.x, this._position.y, this._position.z);
              var updatedNormalMatrix = new Matrix4();
              // If rotation has been applied
              if (this._rotation.x || this._rotation.y || this._rotation.z) {
                  updatedMatrix.translate(0, scaledHeight / 2, 0);
                  updatedMatrix.rotate(this._rotationRadians.x, this._rotationRadians.y, this._rotationRadians.z);
                  updatedNormalMatrix.rotate(this._rotationRadians.x, this._rotationRadians.y, this._rotationRadians.z);
                  updatedMatrix.translate(0, -scaledHeight / 2, 0);
              }
              if (this._scale.x !== 1 || this._scale.y !== 1 || this._scale.z !== 1) {
                  updatedMatrix.scale(this._scale.x, this._scale.y, this._scale.z);
              }
              this._matrix = updatedMatrix;
              this._normalMatrix = updatedNormalMatrix;
          }
      }, {
          key: '_calculateBounds',
          value: function _calculateBounds() {
              this._width = this._getMaxVertexDistance(0, this._vertices.length - 2);
              this._height = this._getMaxVertexDistance(1, this._vertices.length - 1);
              this._depth = this._getMaxVertexDistance(2, this._vertices.length - 1);
          }
      }, {
          key: '_getMaxVertexDistance',
          value: function _getMaxVertexDistance(startIndex, endIndex) {
              var min = 0;
              var max = 0;
              for (var i = startIndex; i < endIndex; i += 3) {
                  var vertexCoord = this._vertices[i];
                  if (vertexCoord < min) min = vertexCoord;
                  if (vertexCoord > max) max = vertexCoord;
              }
              return max - min;
          }
      }, {
          key: 'id',
          get: function get$$1() {
              return this._id;
          }
      }, {
          key: 'x',
          get: function get$$1() {
              return this._position.x;
          },
          set: function set$$1(value) {
              this._position.x = value;
              this._updateMatrix();
          }
      }, {
          key: 'y',
          get: function get$$1() {
              return this._position.y;
          },
          set: function set$$1(value) {
              this._position.y = value;
              this._updateMatrix();
          }
      }, {
          key: 'z',
          get: function get$$1() {
              return this._position.z;
          },
          set: function set$$1(value) {
              this._position.z = value;
              this._updateMatrix();
          }
      }, {
          key: 'center',
          get: function get$$1() {
              return {
                  x: this._position.x,
                  y: this._position.y + this._height / 2 * this._scale.y,
                  z: this._position.z
              };
          }
      }, {
          key: 'rotationX',
          get: function get$$1() {
              return this._rotation.x;
          },
          set: function set$$1(value) {
              this._rotation.x = value;
              this._rotationRadians.x = degreesToRadians(value);
              this._updateMatrix();
          }
      }, {
          key: 'rotationY',
          get: function get$$1() {
              return this._rotation.y;
          },
          set: function set$$1(value) {
              this._rotation.y = value;
              this._rotationRadians.y = degreesToRadians(value);
              this._updateMatrix();
          }
      }, {
          key: 'rotationZ',
          get: function get$$1() {
              return this._rotation.z;
          },
          set: function set$$1(value) {
              this._rotation.z = value;
              this._rotationRadians.z = degreesToRadians(value);
              this._updateMatrix();
          }
      }, {
          key: 'scale',
          get: function get$$1() {
              return this._scale.z;
          },
          set: function set$$1(value) {
              this._scale = { x: value, y: value, z: value };
              this._updateMatrix();
          }
      }, {
          key: 'scaleX',
          get: function get$$1() {
              return this._scale.x;
          },
          set: function set$$1(value) {
              this._scale.x = value;
              this._updateMatrix();
          }
      }, {
          key: 'scaleY',
          get: function get$$1() {
              return this._scale.y;
          },
          set: function set$$1(value) {
              this._scale.y = value;
              this._updateMatrix();
          }
      }, {
          key: 'scaleZ',
          get: function get$$1() {
              return this._scale.z;
          },
          set: function set$$1(value) {
              this._scale.z = value;
              this._updateMatrix();
          }
      }, {
          key: 'vertices',
          get: function get$$1() {
              return this._vertices;
          },
          set: function set$$1(value) {
              this._vertices = value;
          }
      }, {
          key: 'normals',
          get: function get$$1() {
              return this._normals;
          },
          set: function set$$1(value) {
              this._normals = value;
          }
      }, {
          key: 'indices',
          get: function get$$1() {
              return this._indices;
          },
          set: function set$$1(value) {
              this._indices = value;
          }
      }, {
          key: 'uvs',
          get: function get$$1() {
              return this._uvs;
          },
          set: function set$$1(value) {
              this._uvs = value;
          }
      }, {
          key: 'material',
          get: function get$$1() {
              return this._material;
          },
          set: function set$$1(value) {
              this._material = value;
              if (this._onMaterialUpdated) this._onMaterialUpdated(this);
          }
      }, {
          key: 'matrix',
          get: function get$$1() {
              return this._matrix.value;
          }
      }, {
          key: 'normalsMatrix',
          get: function get$$1() {
              return this._normalMatrix.value;
          }
      }, {
          key: 'onMaterialUpdated',
          set: function set$$1(value) {
              this._onMaterialUpdated = value;
              if (this._material) this._onMaterialUpdated(this);
          }
      }]);
      return Mesh;
  }();

  var Cube = function (_Mesh) {
      inherits(Cube, _Mesh);

      function Cube(options) {
          classCallCheck(this, Cube);

          var _this = possibleConstructorReturn(this, (Cube.__proto__ || Object.getPrototypeOf(Cube)).call(this, options));

          if (!options.width) throw new Error('Cube options object is missing a width attribute');
          if (!options.material) throw new Error('Cube options object is missing a material attribute');
          _this._id = 'Cube-' + Date.now();
          _this._width = options.width;
          _this._height = options.height || _this._width;
          _this._depth = options.depth || _this._width;
          _this._generateVertices();
          _this._generateNormals();
          _this._generateIndices();
          _this._generateUVs();
          _this._updateMatrix();
          return _this;
      }

      createClass(Cube, [{
          key: '_generateVertices',
          value: function _generateVertices() {
              var w = this._width / 2;
              var h = this._height;
              var d = this._depth / 2;
              this._vertices = new Float32Array([
              // Front face
              -w, 0, d, w, 0, d, w, h, d, -w, h, d,
              // Back face
              -w, 0, -d, -w, h, -d, w, h, -d, w, 0, -d,
              // Top face
              -w, h, -d, -w, h, d, w, h, d, w, h, -d,
              // Bottom face
              -w, 0, -d, w, 0, -d, w, 0, d, -w, 0, d,
              // Right face
              w, 0, -d, w, h, -d, w, h, d, w, 0, d,
              // Left face
              -w, 0, -d, -w, 0, d, -w, h, d, -w, h, -d]);
          }
      }, {
          key: '_generateNormals',
          value: function _generateNormals() {
              this._normals = new Float32Array([
              // Front face
              0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
              // Back face
              0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
              // Top face
              0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
              // Bottom face
              0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
              // Right face
              1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
              // Left face
              -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
          }
      }, {
          key: '_generateIndices',
          value: function _generateIndices() {
              this._indices = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
          }
      }, {
          key: '_generateUVs',
          value: function _generateUVs() {
              this._uvs = new Float32Array([
              // Front face
              0, 1, 1, 1, 1, 0, 0, 0,
              // Back face
              1, 1, 1, 0, 0, 0, 0, 1,
              // Top face
              0, 0, 0, 1, 1, 1, 1, 0,
              // Bottom face
              0, 1, 1, 1, 1, 0, 0, 0,
              // Right face
              1, 1, 1, 0, 0, 0, 0, 1,
              // Left face
              0, 1, 1, 1, 1, 0, 0, 0]);
          }
      }]);
      return Cube;
  }(Mesh);

  var defaultCircumferenceSegments = 20;
  var defaultHeightSegments = 1;
  var Cylinder = function (_Mesh) {
      inherits(Cylinder, _Mesh);

      function Cylinder(options) {
          classCallCheck(this, Cylinder);

          var _this = possibleConstructorReturn(this, (Cylinder.__proto__ || Object.getPrototypeOf(Cylinder)).call(this, options));

          if (!options.radius) throw new Error('Cylinder options object is mising a radius attribute');
          if (!options.height) throw new Error('Cylinder options object is missing a height attribute');
          if (!options.material) throw new Error('Cylinder options object is missing a material attribute');
          _this._id = 'Cylinder-' + Date.now();
          _this._radius = options.radius;
          _this._width = _this._depth = _this._radius * 2;
          _this._height = options.height;
          _this._segments = options.segments || defaultCircumferenceSegments;
          _this._heightSegments = options.heightSegments || defaultHeightSegments;
          _this._generateMeshData();
          _this._updateMatrix();
          return _this;
      }

      createClass(Cylinder, [{
          key: '_generateMeshData',
          value: function _generateMeshData() {
              var vertexArray = [];
              var normalsArray = [];
              var indicesArray = [];
              var uvsArray = [];
              var segmentAngle = 360 / this._segments;
              var halfSegments = this._segments / 2;
              var startIndex = 0;
              for (var i = 0; i < this._segments; i++) {
                  // Theta = the angle within this face segment
                  var theta = degreesToRadians(segmentAngle * i);
                  var nextTheta = degreesToRadians(segmentAngle * (i + 1));
                  // Calculate the normals
                  var nX1 = Math.cos(theta);
                  var nZ1 = Math.sin(theta);
                  var nX2 = Math.cos(nextTheta);
                  var nZ2 = Math.sin(nextTheta);
                  // Calculate the vertices from the normals, since both require the same math
                  var vX1 = nX1 * this._radius;
                  var vZ1 = nZ1 * this._radius;
                  var vX2 = nX2 * this._radius;
                  var vZ2 = nZ2 * this._radius;
                  // Draw the bottom triangle
                  vertexArray.push(0, 0, 0, vX1, 0, vZ1, vX2, 0, vZ2);
                  // nX/nZ are in the -1 to 1 range (via cosine/sine)
                  // They need to be 0 to 1, so we have to + 1, and
                  // then divide the result by 2
                  uvsArray.push(0.5, 0.5, (nX1 + 1) / 2, (nZ1 + 1) / 2, (nX2 + 1) / 2, (nZ2 + 1) / 2);
                  normalsArray.push(0, -1, 0, 0, -1, 0, 0, -1, 0);
                  indicesArray.push(startIndex, startIndex + 1, startIndex + 2);
                  startIndex += 3;
                  // Draw the middle segments
                  for (var k = 0; k < this._heightSegments; k++) {
                      var h1 = k * (this._height / this._heightSegments);
                      var h2 = (k + 1) * (this._height / this._heightSegments);
                      vertexArray.push(vX1, h1, vZ1, vX1, h2, vZ1, vX2, h2, vZ2, vX2, h1, vZ2);
                      uvsArray.push(i / halfSegments, (k + 1) / this._heightSegments, i / halfSegments, k / this._heightSegments, (i + 1) / halfSegments, k / this._heightSegments, (i + 1) / halfSegments, (k + 1) / this._heightSegments);
                      normalsArray.push(nX1, 0, nZ1, nX1, 0, nZ1, nX2, 0, nZ2, nX2, 0, nZ2);
                      indicesArray.push(startIndex, startIndex + 1, startIndex + 2, startIndex, startIndex + 2, startIndex + 3);
                      startIndex += 4;
                  }
                  // Draw the top triangle
                  vertexArray.push(0, this._height, 0, vX2, this._height, vZ2, vX1, this._height, vZ1);
                  uvsArray.push(0.5, 0.5, (nX2 + 1) / 2, (nZ2 + 1) / 2, (nX1 + 1) / 2, (nZ1 + 1) / 2);
                  normalsArray.push(0, 1, 0, 0, 1, 0, 0, 1, 0);
                  indicesArray.push(startIndex, startIndex + 1, startIndex + 2);
                  startIndex += 3;
              }
              this._vertices = new Float32Array(vertexArray);
              this._normals = new Float32Array(normalsArray);
              this._indices = new Uint16Array(indicesArray);
              this._uvs = new Float32Array(uvsArray);
          }
      }]);
      return Cylinder;
  }(Mesh);

  var FShape = function (_Mesh) {
      inherits(FShape, _Mesh);

      function FShape(options) {
          classCallCheck(this, FShape);

          var _this = possibleConstructorReturn(this, (FShape.__proto__ || Object.getPrototypeOf(FShape)).call(this, options));

          if (!options.width) throw new Error('FShape options object is missing a width attribute');
          if (!options.material) throw new Error('FShape options object is missing a material attribute');
          _this._id = 'FShape-' + Date.now();
          _this._width = options.width;
          _this._height = options.height || Math.floor(_this._width / 2) * 3;
          _this._depth = options.depth || Math.floor(_this._width / 3);
          _this._generateVertices();
          _this._generateNormals();
          _this._generateIndices();
          _this._generateUVs();
          return _this;
      }

      createClass(FShape, [{
          key: '_generateVertices',
          value: function _generateVertices() {
              var w = this._width / 2;
              var thirdW = -w + this._width / 3;
              var twoThirdsW = -w + this._width / 3 * 2;
              var twoFifthsH = this._height / 5 * 2;
              var threeFifthsH = this._height / 5 * 3;
              var fourFifthsH = this._height / 5 * 4;
              var h = this._height;
              var d = this._depth / 2;
              this._vertices = new Float32Array([
              // Left column front
              -w, 0, d, thirdW, 0, d, thirdW, h, d, -w, h, d,
              // top rung front
              thirdW, h, d, thirdW, fourFifthsH, d, w, fourFifthsH, d, w, h, d,
              // middle rung front
              thirdW, threeFifthsH, d, thirdW, twoFifthsH, d, twoThirdsW, twoFifthsH, d, twoThirdsW, threeFifthsH, d,
              // left column back
              -w, 0, -d, -w, h, -d, thirdW, h, -d, thirdW, 0, -d,
              // top rung back
              w, h, -d, w, fourFifthsH, -d, thirdW, fourFifthsH, -d, thirdW, h, -d,
              // middle rung back
              twoThirdsW, threeFifthsH, -d, twoThirdsW, twoFifthsH, -d, thirdW, twoFifthsH, -d, thirdW, threeFifthsH, -d,
              // top
              -w, h, d, w, h, d, w, h, -d, -w, h, -d,
              // top rung right
              w, h, d, w, fourFifthsH, d, w, fourFifthsH, -d, w, h, -d,
              // under top rung
              thirdW, fourFifthsH, -d, w, fourFifthsH, -d, w, fourFifthsH, d, thirdW, fourFifthsH, d,
              // between top rung and middle
              thirdW, fourFifthsH, d, thirdW, threeFifthsH, d, thirdW, threeFifthsH, -d, thirdW, fourFifthsH, -d,
              // top of middle rung
              thirdW, threeFifthsH, d, twoThirdsW, threeFifthsH, d, twoThirdsW, threeFifthsH, -d, thirdW, threeFifthsH, -d,
              // right of middle rung
              twoThirdsW, threeFifthsH, d, twoThirdsW, twoFifthsH, d, twoThirdsW, twoFifthsH, -d, twoThirdsW, threeFifthsH, -d,
              // bottom of middle rung.
              thirdW, twoFifthsH, d, thirdW, twoFifthsH, -d, twoThirdsW, twoFifthsH, -d, twoThirdsW, twoFifthsH, d,
              // right of bottom
              thirdW, twoFifthsH, -d, thirdW, twoFifthsH, d, thirdW, 0, d, thirdW, 0, -d,
              // bottom
              -w, 0, -d, thirdW, 0, -d, thirdW, 0, d, -w, 0, d,
              // left side
              -w, 0, d, -w, h, d, -w, h, -d, -w, 0, -d]);
          }
      }, {
          key: '_generateNormals',
          value: function _generateNormals() {
              this._normals = new Float32Array([
              // left column front
              0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
              // top rung front
              0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
              // middle rung front
              0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
              // left column back
              0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
              // top rung back
              0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
              // middle rung back
              0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
              // top
              0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
              // top rung right
              1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
              // under top rung
              0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
              // between top rung and middle
              1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
              // top of middle rung
              0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
              // right of middle rung
              1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
              // bottom of middle rung.
              0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
              // right of bottom
              1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
              // bottom
              0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
              // left side
              -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
          }
      }, {
          key: '_generateIndices',
          value: function _generateIndices() {
              this._indices = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23, 24, 25, 26, 24, 26, 27, 28, 29, 30, 28, 30, 31, 32, 33, 34, 32, 34, 35, 36, 37, 38, 36, 38, 39, 40, 41, 42, 40, 42, 43, 44, 45, 46, 44, 46, 47, 48, 49, 50, 48, 50, 51, 52, 53, 54, 52, 54, 55, 56, 57, 58, 56, 58, 59, 60, 61, 62, 60, 62, 63]);
          }
      }, {
          key: '_generateUVs',
          value: function _generateUVs() {
              this._uvs = new Float32Array([
              // left column front
              0, 5, 1, 5, 1, 0, 0, 0,
              // top rung front
              0, 0, 0, 1, 2, 1, 2, 0,
              // middle run front
              0, 0, 0, 1, 1, 1, 1, 0,
              // left column back
              0, 5, 0, 0, 1, 0, 1, 5,
              // top rung back
              2, 0, 2, 1, 0, 1, 0, 0,
              // middle rung back
              1, 0, 1, 1, 0, 1, 0, 0,
              // top
              0, 1, 3, 1, 3, 0, 0, 0,
              // top rung right
              1, 0, 1, 1, 0, 1, 0, 0,
              // under top rung
              0, 1, 2, 1, 2, 0, 0, 0,
              // between top and middle rungs
              0, 0, 0, 1, 1, 1, 1, 0,
              // top of middle rung
              0, 1, 1, 1, 1, 0, 0, 0,
              // right of middle rung
              1, 0, 1, 1, 0, 1, 0, 0,
              // bottom of middle rung
              0, 0, 0, 1, 1, 1, 1, 0,
              // right of bottom
              0, 0, 1, 0, 1, 2, 0, 2,
              // bottom
              0, 1, 1, 1, 1, 0, 0, 0,
              // left side
              0, 5, 0, 0, 1, 0, 1, 5]);
          }
      }]);
      return FShape;
  }(Mesh);

  var Plane = function (_Mesh) {
      inherits(Plane, _Mesh);

      function Plane(options) {
          classCallCheck(this, Plane);

          var _this = possibleConstructorReturn(this, (Plane.__proto__ || Object.getPrototypeOf(Plane)).call(this, options));

          _this._tempVertices = [];
          _this._tempNormals = [];
          _this._tempIndices = [];
          _this._tempUvs = [];
          if (!options.width) throw new Error('Plane options object is missing a width attribute');
          if (!options.material) throw new Error('Plane options object is missing a material attribute');
          _this._id = 'Plane-' + Date.now();
          _this._width = options.width;
          _this._height = 0;
          _this._depth = options.depth || _this._width;
          _this._widthDivisions = options.widthDivisions || 0;
          _this._widthSections = _this._widthDivisions + 1;
          _this._depthDivisions = options.depthDivisions || 0;
          _this._depthSections = _this._depthDivisions + 1;
          _this._generateMeshData();
          _this._updateMatrix();
          return _this;
      }

      createClass(Plane, [{
          key: '_generateMeshData',
          value: function _generateMeshData() {
              // Create the surface with as many faces as required
              var previousX = -(this._width / 2);
              var previousZ = this._depth / 2;
              for (var i = 0; i < this._depthSections; i++) {
                  var newZ = previousZ + -this._depth / this._depthSections;
                  previousX = -(this._width / 2);
                  for (var k = 0; k < this._widthSections; k++) {
                      var newX = previousX + this._width / this._widthSections;
                      this._addDivision(previousX, previousZ, newX, newZ);
                      previousX = newX;
                  }
                  previousZ = newZ;
              }
              this._vertices = new Float32Array(this._tempVertices);
              this._normals = new Float32Array(this._tempNormals);
              this._indices = new Uint16Array(this._tempIndices);
              this._uvs = new Float32Array(this._tempUvs);
          }
      }, {
          key: '_addDivision',
          value: function _addDivision(startX, startZ, endX, endZ) {
              var indexArrayCounter = this._tempVertices.length / 3;
              if (this._tempIndices.length === 0) {
                  this._tempIndices.push(0, 1, 2, 0, 2, 3);
              } else {
                  this._tempIndices.push(indexArrayCounter, indexArrayCounter + 1, indexArrayCounter + 2, indexArrayCounter, indexArrayCounter + 2, indexArrayCounter + 3);
              }
              this._tempVertices.push(startX, 0, startZ, endX, 0, startZ, endX, 0, endZ, startX, 0, endZ);
              this._tempNormals.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);
              var startPercentX = (startX + this._width / 2) / this._width;
              var startPercentY = (startZ + this._depth / 2) / this._depth;
              var endPercentX = (endX + this._width / 2) / this._width;
              var endPercentY = (endZ + this._depth / 2) / this._depth;
              this._tempUvs.push(startPercentX, startPercentY, endPercentX, startPercentY, endPercentX, endPercentY, startPercentX, endPercentY);
          }
      }]);
      return Plane;
  }(Mesh);

  var defaultSegments = 20;
  var Sphere = function (_Mesh) {
      inherits(Sphere, _Mesh);

      function Sphere(options) {
          classCallCheck(this, Sphere);

          var _this = possibleConstructorReturn(this, (Sphere.__proto__ || Object.getPrototypeOf(Sphere)).call(this, options));

          if (!options.radius) throw new Error('Sphere options object is missing a radius attribute');
          if (!options.material) throw new Error('Sphere options object is missing a material attribute');
          _this._id = 'Sphere-' + Date.now();
          _this._radius = options.radius;
          _this._width = _this._height = _this._depth = 2 * _this._radius;
          _this._latitudeBands = options.segments || defaultSegments;
          _this._longitudeBands = options.segments || defaultSegments;
          _this._vertexArray = [];
          _this._normalsArray = [];
          _this._uvArray = [];
          _this._generateMeshData();
          _this._updateMatrix();
          return _this;
      }

      createClass(Sphere, [{
          key: '_generateMeshData',
          value: function _generateMeshData() {
              // Explained here: https://gamedev.stackexchange.com/a/60107
              // Helpful ASCII diagram showing how the triangles are built up
              // phi2     phi1
              //  |        |
              //  2------- 1 -- theta1
              //  |\       |
              //  | \___   |
              //  |     \  |
              //  |      \ |
              //  3--------4 -- theta 2
              //
              // Note that at the two caps we just create one triangle
              // which hits the top/bottom point of the sphere
              var tempIndices = [];
              var startIndex = 0;
              for (var i = 0; i < this._longitudeBands; i++) {
                  var theta1 = i / this._longitudeBands * Math.PI;
                  var theta2 = (i + 1) / this._longitudeBands * Math.PI;
                  for (var k = 0; k < this._latitudeBands; k++) {
                      var phi1 = k / this._latitudeBands * 2 * Math.PI;
                      var phi2 = (k + 1) / this._latitudeBands * 2 * Math.PI;
                      var normal1 = this._createNormal(theta1, phi1);
                      var normal2 = this._createNormal(theta1, phi2);
                      var normal3 = this._createNormal(theta2, phi2);
                      var normal4 = this._createNormal(theta2, phi1);
                      var vertex1 = this._createVertex(normal1);
                      var vertex2 = this._createVertex(normal2);
                      var vertex3 = this._createVertex(normal3);
                      var vertex4 = this._createVertex(normal4);
                      var u = 1 - k / (this._longitudeBands / 2);
                      var v = 1 - (this._latitudeBands - i) / this._latitudeBands;
                      var u2 = 1 - (k + 1) / (this._longitudeBands / 2);
                      var v2 = 1 - (this._latitudeBands - (i + 1)) / this._latitudeBands;
                      if (i === 0) {
                          // Top cap of the sphere
                          this._addVertex(vertex1, normal1, u + (u2 - u) / 2, 0);
                          this._addVertex(vertex3, normal3, u2, v2);
                          this._addVertex(vertex4, normal4, u, v2);
                          tempIndices.push(startIndex, startIndex + 1, startIndex + 2);
                          startIndex += 3;
                      } else if (i === this._longitudeBands - 1) {
                          // End cap
                          this._addVertex(vertex3, normal3, u + (u2 - u) / 2, v2);
                          this._addVertex(vertex1, normal1, u, v);
                          this._addVertex(vertex2, normal2, u2, v);
                          tempIndices.push(startIndex, startIndex + 1, startIndex + 2);
                          startIndex += 3;
                      } else {
                          // Body
                          this._addVertex(vertex3, normal3, u2, v2);
                          this._addVertex(vertex4, normal4, u, v2);
                          this._addVertex(vertex1, normal1, u, v);
                          this._addVertex(vertex2, normal2, u2, v);
                          /*
                          this._addVertex(vertex3, normal3, u2, v2);
                          this._addVertex(vertex4, normal4, u, v2);
                          this._addVertex(vertex1, normal1, u, v);
                          this._addVertex(vertex2, normal2, u2, v);
                          */
                          /*this._addVertex(vertex3, normal3, u2, v2);
                          this._addVertex(vertex4, normal4, u2, v);
                          this._addVertex(vertex1, normal1, u, v);
                          this._addVertex(vertex2, normal2, u, v2);*/
                          tempIndices.push(startIndex, startIndex + 1, startIndex + 2, startIndex, startIndex + 2, startIndex + 3);
                          startIndex += 4;
                      }
                  }
              }
              // Generate the typed arrays that WebGL requires
              this._vertices = new Float32Array(this._vertexArray);
              this._normals = new Float32Array(this._normalsArray);
              this._indices = new Uint16Array(tempIndices);
              this._uvs = new Float32Array(this._uvArray);
          }
      }, {
          key: '_addVertex',
          value: function _addVertex(vertex, normal, u, v) {
              // Add a single vertex and it's normal to the JS arrays being built up
              this._vertexArray.push(vertex.x, vertex.y, vertex.z);
              this._normalsArray.push(normal.x, normal.y, normal.z);
              this._uvArray.push(u, v);
          }
      }, {
          key: '_createNormal',
          value: function _createNormal(theta, phi) {
              var sinTheta = Math.sin(theta);
              var cosTheta = Math.cos(theta);
              var sinPhi = Math.sin(phi);
              var cosPhi = Math.cos(phi);
              var xPos = cosPhi * sinTheta;
              var yPos = cosTheta;
              var zPos = sinPhi * sinTheta;
              return {
                  x: xPos,
                  y: yPos,
                  z: zPos
              };
          }
      }, {
          key: '_createVertex',
          value: function _createVertex(normal) {
              return {
                  x: normal.x * this._radius,
                  y: normal.y * this._radius + this._radius,
                  z: normal.z * this._radius
              };
          }
      }]);
      return Sphere;
  }(Mesh);



  var index = /*#__PURE__*/Object.freeze({
    Mesh: Mesh,
    Cube: Cube,
    Cylinder: Cylinder,
    FShape: FShape,
    Plane: Plane,
    Sphere: Sphere
  });

  var FollowCamera = function () {
      function FollowCamera(options) {
          classCallCheck(this, FollowCamera);

          if (!options.fieldOfView) throw new Error('FollowCamera options object is missing fieldOfView attribute');
          this._fieldOfView = options.fieldOfView;
          this._fieldOfViewRadians = degreesToRadians(options.fieldOfView);
          this._zNear = options.zNear || 1;
          this._zFar = options.zFar || 2000;
          this._matrix = new Matrix4();
          this._target = { x: 0, y: 0, z: 0 };
          this._distance = options.distance || 400;
      }

      createClass(FollowCamera, [{
          key: 'followMesh',
          value: function followMesh(mesh, distance) {
              this._targetMesh = mesh;
              if (distance) this._distance = distance;
              this.update();
          }
      }, {
          key: 'resize',
          value: function resize(canvasWidth, canvasHeight) {
              this._aspectRatio = canvasWidth / canvasHeight;
              this.update();
          }
      }, {
          key: 'update',
          value: function update() {
              if (this._targetMesh) {
                  this._updateTarget();
                  this._updateMatrix();
              }
          }
      }, {
          key: '_updateTarget',
          value: function _updateTarget() {
              this._target = this._targetMesh.center;
          }
      }, {
          key: '_updateMatrix',
          value: function _updateMatrix() {
              var projectionMatrix = new Matrix4();
              projectionMatrix.setToPerspective(this._fieldOfViewRadians, this._aspectRatio, this._zNear, this._zFar);
              // New camera position
              var cameraX = this._target.x;
              var cameraY = this._target.y;
              var cameraZ = this._target.z + this._distance;
              this._matrix.setToIdentity();
              this._matrix.translate(cameraX, cameraY, cameraZ);
              var cameraPosition = {
                  x: this._matrix.value[12],
                  y: this._matrix.value[13],
                  z: this._matrix.value[14]
              };
              var xAngleInRadians = degreesToRadians(this._targetMesh.rotationX);
              var yAngleInRadians = degreesToRadians(this._targetMesh.rotationY);
              // Calculate the x and y rotation from the target and camera position
              var directionVector = Object.assign({}, subtractVectors(cameraPosition, this._target), { w: 0 });
              var upDirection = { x: 0, y: 1, z: 0, w: 0 };
              /// pitch = y, yaw = x
              var rotationMatrix = new Matrix4();
              rotationMatrix.rotateY(yAngleInRadians);
              rotationMatrix.rotateX(xAngleInRadians);
              directionVector = transformVector(rotationMatrix, directionVector);
              upDirection = transformVector(rotationMatrix, { x: 0, y: 1, z: 0, w: 0 });
              cameraPosition.x = directionVector.x + this._target.x;
              cameraPosition.y = directionVector.y + this._target.y;
              cameraPosition.z = directionVector.z + this._target.z;
              var viewMatrix = new Matrix4();
              viewMatrix.setToLookAt(cameraPosition, this._target, upDirection);
              viewMatrix.invert();
              this._matrix.value = projectionMatrix.value;
              this._matrix.multiply(viewMatrix.value);
          }
      }, {
          key: 'matrix',
          get: function get$$1() {
              return this._matrix.value;
          }
      }]);
      return FollowCamera;
  }();

  var PerspectiveCamera = function () {
      function PerspectiveCamera(options) {
          classCallCheck(this, PerspectiveCamera);

          this._aspectRatio = 1;
          this._position = { x: 0, y: 0, z: 0 };
          if (!options.fieldOfView) throw new Error('PerspectiveCamera options object is missing fieldOfView attribute');
          this._fieldOfView = options.fieldOfView;
          this._fieldOfViewRadians = degreesToRadians(this._fieldOfView);
          this._zNear = options.zNear || 1;
          this._zFar = options.zFar || 2000;
          this._matrix = new Matrix4();
          this._projectionMatrix = new Matrix4();
          this._viewMatrix = new Matrix4();
          if (options.x) this._position.x = options.x;
          if (options.y) this._position.y = options.y;
          if (options.z) this._position.z = options.z;
          this._angle = { x: 0, y: 0, z: 0 };
          this._angleInRadians = { x: 0, y: 0, z: 0 };
          this._updateMatrix();
      }

      createClass(PerspectiveCamera, [{
          key: "setPosition",
          value: function setPosition(x, y, z) {
              this._position = { x: x, y: y, z: z };
              this._updateMatrix();
          }
      }, {
          key: "resize",
          value: function resize(canvasWidth, canvasHeight) {
              this._aspectRatio = canvasWidth / canvasHeight;
              this._updateMatrix();
          }
      }, {
          key: "update",
          value: function update() {}
      }, {
          key: "_updateMatrix",
          value: function _updateMatrix() {
              this._projectionMatrix.setToPerspective(this._fieldOfViewRadians, this._aspectRatio, this._zNear, this._zFar);
              this._viewMatrix.setToIdentity();
              this._viewMatrix.translate(this._position.x, this._position.y, this._position.z);
              this._viewMatrix.rotateY(this._angleInRadians.y);
              this._viewMatrix.rotateX(this._angleInRadians.x);
              this._viewMatrix.rotateZ(this._angleInRadians.z);
              this._viewMatrix.invert();
              this._matrix.value = this._projectionMatrix.value;
              this._matrix.multiply(this._viewMatrix.value);
          }
      }, {
          key: "matrix",
          get: function get$$1() {
              return this._matrix.value;
          }
      }, {
          key: "x",
          get: function get$$1() {
              return this._position.x;
          },
          set: function set$$1(value) {
              this._position.x = value;
              this._updateMatrix();
          }
      }, {
          key: "y",
          get: function get$$1() {
              return this._position.y;
          },
          set: function set$$1(value) {
              this._position.y = value;
              this._updateMatrix();
          }
      }, {
          key: "z",
          get: function get$$1() {
              return this._position.z;
          },
          set: function set$$1(value) {
              this._position.z = value;
              this._updateMatrix();
          }
      }, {
          key: "angleX",
          get: function get$$1() {
              return this._angle.x;
          },
          set: function set$$1(value) {
              this._angle.x = value;
              this._angleInRadians.x = degreesToRadians(value);
              this._updateMatrix();
          }
      }, {
          key: "angleY",
          get: function get$$1() {
              return this._angle.y;
          },
          set: function set$$1(value) {
              this._angle.y = value;
              this._angleInRadians.y = degreesToRadians(value);
              this._updateMatrix();
          }
      }, {
          key: "angleZ",
          get: function get$$1() {
              return this._angle.z;
          },
          set: function set$$1(value) {
              this._angle.z = value;
              this._angleInRadians.z = degreesToRadians(value);
              this._updateMatrix();
          }
      }]);
      return PerspectiveCamera;
  }();

  var maxSpeed = 300;
  var startSpeed = 50;
  var accelerationTime = 3;
  var maxRotationPerSecond = 75;
  var FreeCamera = function (_PerspectiveCamera) {
      inherits(FreeCamera, _PerspectiveCamera);

      function FreeCamera(options) {
          classCallCheck(this, FreeCamera);

          var _this = possibleConstructorReturn(this, (FreeCamera.__proto__ || Object.getPrototypeOf(FreeCamera)).call(this, options));

          _this._horizontalDeadzoneStart = 0;
          _this._horizontalDeadzoneEnd = 0;
          _this._verticalDeadzoneStart = 0;
          _this._verticalDeadzoneEnd = 0;
          _this._alwaysRotateToMouse = false;
          _this._dragInProgress = false;
          _this._speedPerSecond = startSpeed;
          _this._pressedKeys = [];
          _this._keyDownTime = 0;
          _this._previousUpdateTime = 0;
          _this._xRotationStrength = 0;
          _this._yRotationStrength = 0;
          _this._mouseXRotating = false;
          _this._mouseYRotating = false;
          _this._previousMouseX = 0;
          _this._previousMouseY = 0;
          _this._activeTouches = [];
          _this._previousPinchDiff = { x: 0, y: 0 };
          _this._onKeyDown = function (e) {
              if (!_this._pressedKeys.length) {
                  _this._previousUpdateTime = 0;
              }
              if (_this._pressedKeys.indexOf(e.key) < 0) {
                  _this._pressedKeys.push(e.key);
              }
          };
          _this._onKeyUp = function (e) {
              if (_this._pressedKeys.indexOf(e.key) > -1) {
                  _this._pressedKeys.splice(_this._pressedKeys.indexOf(e.key));
              }
              if (!_this._pressedKeys.length) {
                  _this._speedPerSecond = startSpeed;
                  _this._keyDownTime = 0;
              }
          };
          _this._onMouseDown = function (e) {
              if (!_this._alwaysRotateToMouse) {
                  _this._dragInProgress = true;
                  _this._previousMouseX = e.pageX;
                  _this._previousMouseY = e.pageY;
                  document.addEventListener('mousemove', _this._onMouseMove);
                  document.addEventListener('mouseup', _this._onMouseUp);
              }
          };
          _this._onMouseMove = function (e) {
              if (_this._alwaysRotateToMouse) {
                  if (e.clientX < _this._horizontalDeadzoneStart) {
                      _this._xRotationStrength = 1 - e.clientX / _this._horizontalDeadzoneStart;
                  } else if (e.clientX > _this._horizontalDeadzoneEnd) {
                      _this._xRotationStrength = -((e.clientX - _this._horizontalDeadzoneEnd) / (window.innerWidth - _this._horizontalDeadzoneEnd));
                  } else {
                      _this._xRotationStrength = 0;
                  }
                  if (e.clientY < _this._verticalDeadzoneStart) {
                      _this._yRotationStrength = 1 - e.clientY / _this._verticalDeadzoneStart;
                  } else if (e.clientY > _this._verticalDeadzoneEnd) {
                      _this._yRotationStrength = -((e.clientY - _this._verticalDeadzoneEnd) / (window.innerHeight - _this._verticalDeadzoneEnd));
                  } else {
                      _this._yRotationStrength = 0;
                  }
                  _this._mouseXRotating = _this._xRotationStrength !== 0;
                  _this._mouseYRotating = _this._yRotationStrength !== 0;
              } else if (!_this._alwaysRotateToMouse && _this._dragInProgress) {
                  var diffX = e.pageX - _this._previousMouseX;
                  var diffY = e.pageY - _this._previousMouseY;
                  _this.angleY += diffX / window.innerWidth * 180;
                  _this.angleX += diffY / window.innerHeight * 180;
                  _this._previousMouseX = e.pageX;
                  _this._previousMouseY = e.pageY;
              }
          };
          _this._onMouseUp = function (e) {
              _this._dragInProgress = false;
              document.removeEventListener('mousemove', _this._onMouseMove);
              document.removeEventListener('mouseup', _this._onMouseUp);
          };
          _this._onTouchStart = function (e) {
              if (!_this._activeTouches.length) {
                  document.addEventListener('touchmove', _this._onTouchMove);
                  document.addEventListener('touchend', _this._onTouchEnd);
              }
              var touch = e.touches[0];
              _this._activeTouches.push(touch);
          };
          _this._onTouchMove = function (e) {
              if (e.touches.length === 2) {
                  // Check for pinch-zooming
                  var currentDiff = {
                      x: Math.abs(e.touches[0].pageX - e.touches[1].pageX),
                      y: Math.abs(e.touches[0].pageY - e.touches[1].pageY)
                  };
                  var movementDirection = { x: 0, y: 0, z: 0, w: 0 };
                  if (_this._previousPinchDiff.x > 0 || _this._previousPinchDiff.y > 0) {
                      if (currentDiff.x > _this._previousPinchDiff.x) {
                          // Distance X has increased
                          movementDirection.z = -1;
                      } else if (currentDiff.x < _this._previousPinchDiff.x) {
                          // Distance has decreased
                          movementDirection.z = 1;
                      } else if (currentDiff.y > _this._previousPinchDiff.y) {
                          movementDirection.z = -1;
                      } else if (currentDiff.y < _this._previousPinchDiff.y) {
                          movementDirection.z = 1;
                      }
                      if (movementDirection.z) {
                          // Reset the rotation matrix
                          _this._rotationMatrix.setToIdentity();
                          if (_this._angleInRadians.x) _this._rotationMatrix.rotateX(_this._angleInRadians.x);
                          if (_this._angleInRadians.y) _this._rotationMatrix.rotateY(_this._angleInRadians.y);
                          // Perform the zoom whil respecting camera angle
                          var adjustment = transformVector(_this._rotationMatrix, movementDirection);
                          // TODO: Scale the increment according to the size of the difference between current and previous gaps
                          var speedIncrement = 3;
                          _this._position = {
                              x: _this._position.x += adjustment.x * speedIncrement,
                              y: _this._position.y += adjustment.y * speedIncrement,
                              z: _this._position.z += adjustment.z * speedIncrement
                          };
                      }
                  }
                  _this._previousPinchDiff = currentDiff;
              } else {
                  // Rotate the camera
                  var touch = e.touches[0];
                  var diffX = touch.pageX - _this._activeTouches[0].pageX;
                  var diffY = touch.pageY - _this._activeTouches[0].pageY;
                  _this.angleY += diffX / window.innerWidth * 180;
                  _this.angleX += diffY / window.innerHeight * 180;
              }
              // Update the cached touch data
              for (var i = 0; i < e.touches.length; i++) {
                  for (var j = 0; j < _this._activeTouches.length; j++) {
                      if (e.touches[i].identifier === _this._activeTouches[j].identifier) {
                          _this._activeTouches[j] = e.touches[i];
                          break;
                      }
                  }
              }
              e.preventDefault();
          };
          _this._onTouchEnd = function (e) {
              _this._activeTouches = [];
              _this._previousPinchDiff = {
                  x: 0,
                  y: 0
              };
              document.removeEventListener('touchmove', _this._onTouchMove);
              document.removeEventListener('touchend', _this._onTouchEnd);
          };
          _this._onWindowResized = function () {
              _this._updateDeadzones();
          };
          _this._onKeyFrameTimerTicked = function (updateTime) {
              updateTime *= 0.001;
              if (!_this._previousUpdateTime) _this._previousUpdateTime = updateTime;
              _this._clearKeyFrameTimer();
              var timePassed = updateTime - _this._previousUpdateTime;
              _this._previousUpdateTime = updateTime;
              if (_this._pressedKeys.length) {
                  if (!_this._keyDownTime) _this._keyDownTime = updateTime;
                  var speedIncrement = timePassed * _this._speedPerSecond;
                  _this._pressedKeys.forEach(function (keyCode) {
                      _this._updatePosition(keyCode, speedIncrement);
                  });
              }
              _this._clearKeyRotations();
              if (_this._alwaysRotateToMouse) {
                  if (_this._xRotationStrength) {
                      _this.angleY += maxRotationPerSecond * _this._xRotationStrength * timePassed;
                  }
                  if (_this._yRotationStrength) {
                      _this.angleX += maxRotationPerSecond * _this._yRotationStrength * timePassed;
                  }
              }
              _this._updateMatrix();
              // Up the speed every second
              if (_this._pressedKeys.length) {
                  _this._speedPerSecond = Math.min(startSpeed + (updateTime - _this._keyDownTime) / accelerationTime * (maxSpeed - startSpeed), maxSpeed);
              } else {
                  _this._speedPerSecond = 0;
              }
              _this._startKeyFrameTimer();
          };
          _this._rotationMatrix = new Matrix4();
          _this._updateDeadzones();
          return _this;
      }

      createClass(FreeCamera, [{
          key: 'enableControls',
          value: function enableControls() {
              document.addEventListener('keydown', this._onKeyDown);
              document.addEventListener('keyup', this._onKeyUp);
              document.addEventListener('mousemove', this._onMouseMove);
              document.addEventListener('touchstart', this._onTouchStart);
              window.addEventListener('resize', this._onWindowResized);
              if (!this._alwaysRotateToMouse) {
                  document.addEventListener('mousedown', this._onMouseDown);
              } else {
                  document.addEventListener('mousemove', this._onMouseMove);
              }
              this._startKeyFrameTimer();
          }
      }, {
          key: 'disableControls',
          value: function disableControls() {
              document.removeEventListener('keydown', this._onKeyDown);
              document.removeEventListener('keyup', this._onKeyUp);
              document.removeEventListener('touchstart', this._onTouchStart);
              window.removeEventListener('resize', this._onWindowResized);
              if (!this._alwaysRotateToMouse) {
                  document.removeEventListener('mousedown', this._onMouseDown);
                  if (this._dragInProgress) {
                      this._onMouseUp();
                  }
              } else {
                  document.removeEventListener('mousemove', this._onMouseMove);
              }
              this._clearKeyFrameTimer();
          }
      }, {
          key: '_startKeyFrameTimer',
          value: function _startKeyFrameTimer() {
              this._clearKeyFrameTimer();
              if (!this._keyFrameTimer) {
                  this._keyFrameTimer = requestAnimationFrame(this._onKeyFrameTimerTicked.bind(this));
              }
          }
      }, {
          key: '_clearKeyFrameTimer',
          value: function _clearKeyFrameTimer() {
              if (this._keyFrameTimer) {
                  cancelAnimationFrame(this._keyFrameTimer);
                  this._keyFrameTimer = undefined;
              }
          }
      }, {
          key: '_updateDeadzones',
          value: function _updateDeadzones() {
              this._horizontalDeadzoneStart = window.innerWidth / 2 - Math.min(200, window.innerWidth / 8);
              this._horizontalDeadzoneEnd = window.innerWidth / 2 + Math.min(200, window.innerWidth / 8);
              this._verticalDeadzoneStart = window.innerHeight / 2 - Math.min(200, window.innerHeight / 8);
              this._verticalDeadzoneEnd = window.innerHeight / 2 + Math.min(200, window.innerHeight / 8);
          }
      }, {
          key: '_updatePosition',
          value: function _updatePosition(key, speedIncrement) {
              this._rotationMatrix.setToIdentity();
              if (this._angleInRadians.x) this._rotationMatrix.rotateX(this._angleInRadians.x);
              if (this._angleInRadians.y) this._rotationMatrix.rotateY(this._angleInRadians.y);
              var movementDirection = { x: 0, y: 0, z: 0, w: 0 };
              switch (key) {
                  case 's':
                      // Backwards (S)
                      movementDirection = { x: 0, y: 0, z: 1, w: 0 };
                      break;
                  case 'w':
                      // Forwards (W)
                      movementDirection = { x: 0, y: 0, z: -1, w: 0 };
                      break;
                  case 'a':
                      // Left (A)
                      movementDirection = { x: -1, y: 0, z: 0, w: 0 };
                      break;
                  case 'd':
                      // Right (D)
                      movementDirection = { x: 1, y: 0, z: 0, w: 0 };
                      break;
                  default:
                      break;
              }
              var adjustment = transformVector(this._rotationMatrix, movementDirection);
              this._position = {
                  x: this._position.x += adjustment.x * speedIncrement,
                  y: this._position.y += adjustment.y * speedIncrement,
                  z: this._position.z += adjustment.z * speedIncrement
              };
          }
      }, {
          key: '_clearKeyRotations',
          value: function _clearKeyRotations() {
              if (this._pressedKeys.indexOf('ArrowLeft') === -1 && this._pressedKeys.indexOf('ArrowRight') === -1 && !this._mouseXRotating) {
                  this._xRotationStrength = 0;
              }
              if (this._pressedKeys.indexOf('ArrowUp') === -1 && this._pressedKeys.indexOf('ArrowDown') === -1 && !this._mouseYRotating) {
                  this._yRotationStrength = 0;
              }
          }
      }, {
          key: 'alwaysRotateToMouse',
          set: function set$$1(value) {
              this.disableControls();
              this._alwaysRotateToMouse = value;
              this.enableControls();
          }
      }]);
      return FreeCamera;
  }(PerspectiveCamera);

  var LookAtCamera = function () {
      function LookAtCamera(options) {
          classCallCheck(this, LookAtCamera);

          this._position = { x: 0, y: 0, z: 0 };
          if (!options.fieldOfView) throw new Error('LookAtCamera options object is missing fieldOfView attribute');
          if (options.x) this._position.x = options.x;
          if (options.y) this._position.y = options.y;
          if (options.z) this._position.z = options.z;
          this._fieldOfView = options.fieldOfView;
          this._fieldOfViewRadians = degreesToRadians(this._fieldOfView);
          this._zNear = options.zNear || 1;
          this._zFar = options.zFar || 2000;
          this._matrix = new Matrix4();
          this._projectionMatrix = new Matrix4();
          this._viewMatrix = new Matrix4();
          this._targetCoords = { x: 0, y: 0, z: 0 };
          this._updateMatrix();
      }

      createClass(LookAtCamera, [{
          key: 'setPosition',
          value: function setPosition(x, y, z) {
              this._position.x = x;
              this._position.y = y;
              this._position.z = z;
              this._updateMatrix();
          }
      }, {
          key: 'resize',
          value: function resize(canvasWidth, canvasHeight) {
              this._aspectRatio = canvasWidth / canvasHeight;
              this._updateMatrix();
          }
      }, {
          key: 'lookAt',
          value: function lookAt(meshOrPosition) {
              this._target = meshOrPosition;
              this._updateMatrix();
          }
      }, {
          key: 'update',
          value: function update() {
              if (this._target instanceof Mesh) {
                  this._updateTargetCoords();
              }
              this._updateMatrix();
          }
      }, {
          key: '_updateTargetCoords',
          value: function _updateTargetCoords() {
              if (this._target instanceof Mesh) {
                  this._targetCoords = this._target.center;
              } else {
                  this._targetCoords = this._target;
              }
          }
      }, {
          key: '_updateMatrix',
          value: function _updateMatrix() {
              if (this._target) {
                  this._updateTargetCoords();
                  this._projectionMatrix.setToPerspective(this._fieldOfViewRadians, this._aspectRatio, this._zNear, this._zFar);
                  this._matrix.setToIdentity();
                  this._matrix.translate(this._position.x, this._position.y, this._position.z);
                  var cameraPosition = {
                      x: this._matrix.value[12],
                      y: this._matrix.value[13],
                      z: this._matrix.value[14]
                  };
                  var upDirection = { x: 0, y: 1, z: 0 };
                  this._viewMatrix.setToLookAt(cameraPosition, this._targetCoords, upDirection);
                  this._viewMatrix.invert();
                  this._matrix.value = this._projectionMatrix.value;
                  this._matrix.multiply(this._viewMatrix.value);
              }
          }
      }, {
          key: 'matrix',
          get: function get$$1() {
              return this._matrix.value;
          }
      }, {
          key: 'x',
          get: function get$$1() {
              return this._position.x;
          },
          set: function set$$1(value) {
              this._position.x = value;
              this._updateMatrix();
          }
      }, {
          key: 'y',
          get: function get$$1() {
              return this._position.y;
          },
          set: function set$$1(value) {
              this._position.y = value;
              this._updateMatrix();
          }
      }, {
          key: 'z',
          get: function get$$1() {
              return this._position.z;
          },
          set: function set$$1(value) {
              this._position.z = value;
              this._updateMatrix();
          }
      }]);
      return LookAtCamera;
  }();

  var ProjectionCamera = function () {
      function ProjectionCamera(options) {
          classCallCheck(this, ProjectionCamera);

          this._left = 0;
          this._right = 0;
          this._top = 0;
          this._bottom = 0;
          this._distanceMultiplier = typeof options.distanceMultiplier === 'number' ? options.distanceMultiplier : 0.25;
          this._zNear = options.zNear || 400;
          this._zFar = options.zFar || -200;
          this._matrix = new Matrix4();
          this._orthoMatrix = new Matrix4();
          this._orthoMatrix.setToOrthographic(this._top, this._right, this._bottom, this._left, this._zNear, this._zFar);
          this._updateMatrix();
      }

      createClass(ProjectionCamera, [{
          key: 'resize',
          value: function resize(canvasWidth, canvasHeight) {
              this._right = canvasWidth;
              this._bottom = canvasHeight;
              this._orthoMatrix.setToOrthographic(this._top, this._right, this._bottom, this._left, this._zNear, this._zFar);
          }
      }, {
          key: 'update',
          value: function update() {}
      }, {
          key: '_updateMatrix',
          value: function _updateMatrix() {
              this._matrix.setToIdentity();
              this._matrix.copyZToW(this._distanceMultiplier);
              this._matrix.multiply(this._orthoMatrix.value);
              this._matrix.scale(1, 1, -1);
              this._matrix.value[1] *= -1;
              this._matrix.value[5] *= -1;
              this._matrix.value[9] *= -1;
              this._matrix.value[13] *= -1;
          }
      }, {
          key: 'matrix',
          get: function get$$1() {
              this._updateMatrix();
              return this._matrix.value;
          }
      }]);
      return ProjectionCamera;
  }();



  var index$1 = /*#__PURE__*/Object.freeze({
    FollowCamera: FollowCamera,
    FreeCamera: FreeCamera,
    LookAtCamera: LookAtCamera,
    PerspectiveCamera: PerspectiveCamera,
    ProjectionCamera: ProjectionCamera
  });

  var DirectionalLight = function () {
      function DirectionalLight(options) {
          classCallCheck(this, DirectionalLight);

          if (typeof options.directionX === 'undefined') throw new Error('DirectionalLight options object missing directionX attribute');
          if (typeof options.directionY === 'undefined') throw new Error('DirectionalLight options object missing directionY attribute');
          if (typeof options.directionZ === 'undefined') throw new Error('DirectionalLight options object missing directionZ attribute');
          this._direction = {
              x: options.directionX,
              y: options.directionY,
              z: options.directionZ
          };
          this._color = options.color || { r: 255, g: 255, b: 255 };
          this._updateUnitColor();
      }

      createClass(DirectionalLight, [{
          key: '_updateUnitColor',
          value: function _updateUnitColor() {
              this._colorUnits = convertColorToUnits(this._color);
          }
      }, {
          key: 'isDirectional',
          get: function get$$1() {
              return true;
          }
      }, {
          key: 'direction',
          get: function get$$1() {
              return this._direction;
          },
          set: function set$$1(direction) {
              this._direction = direction;
          }
      }, {
          key: 'color',
          get: function get$$1() {
              return this._color;
          },
          set: function set$$1(color) {
              this._color = color;
              this._updateUnitColor();
          }
      }, {
          key: 'colorInUnits',
          get: function get$$1() {
              return [this._colorUnits.r, this._colorUnits.g, this._colorUnits.b];
          }
      }]);
      return DirectionalLight;
  }();



  var index$2 = /*#__PURE__*/Object.freeze({
    DirectionalLight: DirectionalLight
  });

  var BaseMaterial = function () {
      function BaseMaterial() {
          classCallCheck(this, BaseMaterial);

          this.isTextureMap = false;
          this.vertexShader = "#version 300 es\n    in vec4 a_position;\n    in vec3 a_normal;\n\n    // Uniforms\n    uniform mat4 u_matrix;\n    uniform mat4 u_worldMatrix;\n\n    void main() {\n      gl_Position = a_position;\n      v_normal = a_normal;\n    }\n  ";
          this.fragmentShader = "#version 300 es\n    precision mediump float;\n\n    in vec3 v_normal;\n\n    uniform vec3 u_reverseLightDirection;\n    uniform vec3 u_lightColor;\n    uniform vec4 u_color;\n\n    out vec4 outColor;\n\n    void main() {\n      outColor = {r: 0, g: 0, b: 0, a: 1};\n    }\n  ";
      }

      createClass(BaseMaterial, [{
          key: "program",
          get: function get$$1() {
              return this._program;
          },
          set: function set$$1(value) {
              this._program = value;
          }
      }]);
      return BaseMaterial;
  }();

  var FlatColor = function (_BaseMaterial) {
      inherits(FlatColor, _BaseMaterial);

      function FlatColor(color) {
          classCallCheck(this, FlatColor);

          var _this = possibleConstructorReturn(this, (FlatColor.__proto__ || Object.getPrototypeOf(FlatColor)).call(this));

          _this.vertexShader = '#version 300 es\n    in vec4 a_position;\n    in vec3 a_normal;\n\n    // Uniforms\n    uniform mat4 u_matrix;\n    uniform mat4 u_worldMatrix;\n\n    out vec3 v_normal;\n\n    void main() {\n      gl_Position = u_matrix * a_position;\n\n      // Ignore translation when working with normals\n      v_normal = mat3(u_worldMatrix) * a_normal;\n    }\n  ';
          _this.fragmentShader = '#version 300 es\n    precision mediump float;\n\n    in vec3 v_normal;\n\n    uniform vec3 u_reverseLightDirection;\n    uniform vec3 u_lightColor;\n    uniform vec4 u_color;\n\n    out vec4 outColor;\n\n    void main() {\n      // As v_normal is a varying, it wont be a unit vector.\n      // Normalising it will make it a unit vector again\n      vec3 normal = normalize(v_normal);\n\n      // Compute the light by taking the dot product\n      // of the normal and the light\'s reverse direction\n      float light = dot(normal, u_reverseLightDirection);\n\n      outColor = u_color;\n\n      // Multiply the colour portion (not alpha) by the light\n      outColor.rgb *= light * u_lightColor;\n    }\n  ';
          _this._color = { r: 0, g: 0, b: 0, a: 1 };
          _this._colorInUnits = { r: 0, g: 0, b: 0, a: 1 };
          if (!color['a']) color['a'] = 1;
          _this._color = color;
          _this._colorInUnits = convertColorToUnits(color);
          return _this;
      }

      createClass(FlatColor, [{
          key: 'color',
          get: function get$$1() {
              return this._color;
          },
          set: function set$$1(value) {
              if (!value['a']) value['a'] = 1;
              this._color = value;
              this._colorInUnits = convertColorToUnits(value);
          }
      }, {
          key: 'colorInUnits',
          get: function get$$1() {
              return this._colorInUnits;
          }
      }]);
      return FlatColor;
  }(BaseMaterial);

  var ImageLoaderCore = function () {
      function ImageLoaderCore() {
          var _this = this;

          classCallCheck(this, ImageLoaderCore);

          this._onImageLoadComplete = function (url, image, callback) {
              _this._loadingImageUrls.forEach(function (loadingUrl, index) {
                  if (loadingUrl === url) {
                      _this._loadingImageUrls.splice(index);
                      _this._loadingImages.splice(index);
                  }
              });
              if (callback) callback(url, image);
          };
          this._loadingImages = [];
          this._loadingImageUrls = [];
      }

      createClass(ImageLoaderCore, [{
          key: 'loadImage',
          value: function loadImage(url, callback) {
              var _this2 = this;

              var image = new Image();
              image.addEventListener('load', function () {
                  _this2._onImageLoadComplete(url, image, callback);
              });
              image.src = url;
              this._loadingImages.push(image);
              this._loadingImageUrls.push(url);
          }
      }]);
      return ImageLoaderCore;
  }();

  var ImageLoader = new ImageLoaderCore();

  var Texture = function (_BaseMaterial) {
      inherits(Texture, _BaseMaterial);

      function Texture(imageUrl) {
          classCallCheck(this, Texture);

          var _this = possibleConstructorReturn(this, (Texture.__proto__ || Object.getPrototypeOf(Texture)).call(this));

          _this.vertexShader = '#version 300 es\n    in vec4 a_position;\n    in vec3 a_normal;\n    in vec2 a_texcoord;\n\n    // Uniforms\n    uniform mat4 u_matrix;\n    uniform mat4 u_worldMatrix;\n\n    out vec3 v_normal;\n    out vec2 v_texcoord;\n\n    void main() {\n      gl_Position = u_matrix * a_position;\n\n      // Ignore translation when working with normals\n      v_normal = mat3(u_worldMatrix) * a_normal;\n\n      v_texcoord = a_texcoord;\n    }\n  ';
          _this.fragmentShader = '#version 300 es\n    precision mediump float;\n\n    in vec3 v_normal;\n    in vec2 v_texcoord;\n\n    uniform vec3 u_reverseLightDirection;\n    uniform vec3 u_lightColor;\n\n    uniform sampler2D u_texture;\n\n    out vec4 outColor;\n\n    void main() {\n      // As v_normal is a varying, it wont be a unit vector.\n      // Normalising it will make it a unit vector again\n      vec3 normal = normalize(v_normal);\n\n      // Compute the light by taking the dot product\n      // of the normal and the light\'s reverse direction\n      float light = dot(normal, u_reverseLightDirection);\n\n      outColor = texture(u_texture, v_texcoord);\n\n      // Multiply the colour portion (not alpha) by the light\n      outColor.rgb *= light * u_lightColor;\n    }\n  ';
          _this.isTextureMap = true;
          _this._imageUrl = imageUrl;
          return _this;
      }

      createClass(Texture, [{
          key: 'loadImage',
          value: function loadImage(callback) {
              var _this2 = this;

              ImageLoader.loadImage(this._imageUrl, function (url, image) {
                  _this2._image = image;
                  callback(_this2);
              });
          }
      }, {
          key: 'imageUrl',
          get: function get$$1() {
              return this._imageUrl;
          },
          set: function set$$1(value) {
              this._imageUrl = value;
              this._texture = undefined;
          }
      }, {
          key: 'image',
          get: function get$$1() {
              return this._image;
          }
      }, {
          key: 'texture',
          get: function get$$1() {
              return this._texture;
          },
          set: function set$$1(value) {
              this._texture = value;
          }
      }]);
      return Texture;
  }(BaseMaterial);



  var index$3 = /*#__PURE__*/Object.freeze({
    BaseMaterial: BaseMaterial,
    FlatColor: FlatColor,
    Texture: Texture
  });



  var index$4 = /*#__PURE__*/Object.freeze({
    degreesToRadians: degreesToRadians,
    radiansToDegrees: radiansToDegrees
  });

  var ObjLoader = function () {
      function ObjLoader(url, callback) {
          classCallCheck(this, ObjLoader);

          this._tempVertices = [];
          this._tempNormals = [];
          this._tempIndices = [];
          this._tempUVs = [];
          this._finalVertices = [];
          this._finalNormals = [];
          this._finalIndices = [];
          this._finalUVs = [];
          this._currentFaceIndex = 0;
          this._vertices = [];
          this._normals = [];
          this._indices = [];
          this._uvs = [];
          this._url = url;
          this._callback = callback;
          this._loadFile();
      }

      createClass(ObjLoader, [{
          key: '_loadFile',
          value: function _loadFile() {
              var _this = this;

              this._fetchRequest = fetch(this._url).then(function (response) {
                  if (!response.ok) {
                      throw Error(response.statusText);
                  }
                  return response.text();
              }).then(function (response) {
                  return _this._onLoadComplete(response);
              }).catch(this._onLoadError);
          }
      }, {
          key: '_parseModelData',
          value: function _parseModelData() {
              var previousLineBreakIndex = 0;
              var lineBreakIndex = this._modelData.indexOf('\n', 0);
              var lineToParse = '';
              // While a new line break remains in the file
              while (lineBreakIndex > -1) {
                  // Get the next line of the file to check
                  lineToParse = this._modelData.substring(previousLineBreakIndex, lineBreakIndex).trim();
                  switch (lineToParse.charAt(0)) {
                      case 'v':
                          this._processVertexLine(lineToParse);
                          break;
                      case 'f':
                          this._processFace(lineToParse);
                          break;
                      default:
                          break;
                  }
                  previousLineBreakIndex = lineBreakIndex + 1;
                  lineBreakIndex = this._modelData.indexOf('\n', previousLineBreakIndex);
              }
              this._indices = this._finalIndices;
              this._vertices = this._finalVertices;
              this._normals = this._finalNormals;
              this._uvs = this._finalUVs;
              if (this._callback) this._callback({
                  indices: this._indices,
                  vertices: this._vertices,
                  normals: this._normals,
                  uvs: this._uvs
              });
          }
      }, {
          key: '_processVertexLine',
          value: function _processVertexLine(lineToParse) {
              // A vertex line can be either vertex position (v), vertex texture (vt), or vertex normal (vn)
              // in the form v(t/n) x y z
              // Split the line on spaces
              var valueArray = lineToParse.split(' ');
              // Remove the v/vt/vn part from the array
              valueArray.shift();
              switch (lineToParse.charAt(1)) {
                  case ' ':
                      // Vertex position
                      this._tempVertices.push(parseFloat(valueArray[0]), parseFloat(valueArray[1]), parseFloat(valueArray[2]));
                      break;
                  case 't':
                      // Vertex texture data
                      this._tempUVs.push(parseFloat(valueArray[0]), parseFloat(valueArray[1]));
                      break;
                  case 'n':
                      // Vertex normal
                      this._tempNormals.push(parseFloat(valueArray[0]), parseFloat(valueArray[1]), parseFloat(valueArray[2]));
                      break;
                  default:
                      break;
              }
          }
      }, {
          key: '_processFace',
          value: function _processFace(lineToParse) {
              // Note that all index values start at 1 in .obj files
              // so we always need to subtract 1 to get zero-indexed values
              // Faces can appear in the following forms
              // (vertex / uv / normal indices)
              // Quad: f 1/1/1 2/2/1 3/3/1 4/4/1
              // Triangle: f 1/1/1 2/2/1 3/3/1
              // Triangle without UVs: f 1//1 2//1 3//1
              var valueArray = lineToParse.split(' ');
              // Remove the 'f' from the array
              valueArray.shift();
              var isQuad = false;
              var previousFaceData = {};
              var index = 0;
              var vertexData = void 0;
              // Loop through each vertex in the face (each item is a string like '1/1/1')
              for (var i = 0; i < valueArray.length; i++) {
                  // If i == 3, we know this line describes a quad
                  if (i === 3 && !isQuad) {
                      i = 2; // The last vertex in the 1st triangle is the start of the 2nd triangle
                      isQuad = true;
                  }
                  // Check if this face has already been processed
                  if (valueArray[i] in previousFaceData) {
                      this._finalIndices.push(previousFaceData[valueArray[i]]);
                  } else {
                      // New vertex data
                      vertexData = valueArray[i].split('/');
                      // New index will be vertex index + 3 (x,y,z)
                      index = (parseInt(vertexData[0], 10) - 1) * 3;
                      this._finalVertices.push(this._tempVertices[index], this._tempVertices[index + 1], this._tempVertices[index + 2]);
                      // Do the same for the normals
                      index = (parseInt(vertexData[2], 10) - 1) * 3;
                      this._finalNormals.push(this._tempNormals[index], this._tempNormals[index + 1], this._tempNormals[index + 2]);
                      // And for UVs - but check a value exists first as they're optional
                      if (vertexData[1] !== '') {
                          index = (parseInt(vertexData[1], 10) - 1) * 2;
                          this._finalUVs.push(this._tempUVs[index], 1 - this._tempUVs[index + 1] // Flip the Y so that Y is upwards to match our WebGL co-ordinate space
                          );
                      }
                      previousFaceData[valueArray[i]] = this._currentFaceIndex;
                      this._finalIndices.push(this._currentFaceIndex);
                      this._currentFaceIndex++;
                  }
                  // In a quad, the last vertex of the second triangle is the first vertex in the first triangle
                  if (i === 3 && isQuad) {
                      this._finalIndices.push(previousFaceData[valueArray[0]]);
                  }
              }
          }
      }, {
          key: '_onLoadComplete',
          value: function _onLoadComplete(data) {
              this._modelData = data.trim() + '\n';
              this._parseModelData();
          }
      }, {
          key: '_onLoadError',
          value: function _onLoadError(error) {
              throw new Error(error);
          }
      }]);
      return ObjLoader;
  }();



  var index$5 = /*#__PURE__*/Object.freeze({
    ImageLoader: ImageLoader,
    ObjLoader: ObjLoader
  });

  exports.cameras = index$1;
  exports.meshes = index;
  exports.lights = index$2;
  exports.loaders = index$5;
  exports.materials = index$3;
  exports.utils = index$4;
  exports.World = World;
  exports.Scene = Scene;
  exports.Motion = Motion;

  return exports;

}({}));
//# sourceMappingURL=oomph3d.min.js.map
